[1mdiff --git a/Apps.cpp b/Apps.cpp[m
[1mindex 25ca981..aa129cf 100644[m
[1m--- a/Apps.cpp[m
[1m+++ b/Apps.cpp[m
[36m@@ -1,182 +1,182 @@[m
 #include "Apps.h"[m
 //#include "Arduino.h"[m
 #include "PretbakSettings.h"[m
[31m-[m
[32m+[m[41m [m
 Apps::Apps(){[m
 };[m
[31m-[m
[32m+[m[41m [m
 void Apps::setPeripherals( BinaryInput binaryInputs[], Potentio* potentio, DisplayManagement* ledDisp, Buzzer* buzzer){[m
   this->buzzer = buzzer;[m
   this->binaryInputs = binaryInputs;[m
   this->potentio = potentio;[m
   this->ledDisp = ledDisp;[m
 }[m
[31m-[m
[32m+[m[41m [m
 void Apps::appSelector(bool init, uint8_t selector){[m
[31m-[m
[31m-	if (init){[m
[31m-		// title mode (title screen will be displayed before real app starts)[m
[31m-		this->app_init_mode = true;[m
[32m+[m[41m [m
[32m+[m[32m    if (init){[m
[32m+[m[32m        // title mode (title screen will be displayed before real app starts)[m
[32m+[m[32m        this->app_init_mode = true;[m
     //Serial.println("initapps");[m
[31m-	}[m
[31m-	[m
[31m-	if (this->app_init_mode){[m
[31m-		[m
[31m-		if (this->init_app(init, selector)){ [m
[31m-			// do init routine, if finished,end of init.[m
[31m-			this->app_init_mode = false;[m
[31m-			init = true;[m
[31m-		}[m
[31m-	}[m
[31m-	[m
[31m-	// not as else statement, to have the init properly transferred after app beginning screen.[m
[31m-	if (!this->app_init_mode){[m
[31m-		[m
[31m-		switch (selector) {[m
[31m-		case 0:[m
[31m-		  this->modeCountingLettersAndChars(init);[m
[31m-		  break;[m
[31m-		  [m
[31m-		case 1:[m
[31m-		  //sound fun with notes[m
[31m-		  this->modeSoundNotes();[m
[31m-		  break;[m
[31m-		  [m
[31m-		case 2:[m
[31m-		  //sound fun with frequencies.[m
[32m+[m[32m    }[m
[32m+[m[41m     [m
[32m+[m[32m    if (this->app_init_mode){[m
[32m+[m[41m         [m
[32m+[m[32m        if (this->init_app(init, selector)){[m[41m [m
[32m+[m[32m            // do init routine, if finished,end of init.[m
[32m+[m[32m            this->app_init_mode = false;[m
[32m+[m[32m            init = true;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[41m     [m
[32m+[m[32m    // not as else statement, to have the init properly transferred after app beginning screen.[m
[32m+[m[32m    if (!this->app_init_mode){[m
[32m+[m[41m         [m
[32m+[m[32m        switch (selector) {[m
[32m+[m[32m        case 0:[m
[32m+[m[32m          this->modeCountingLettersAndChars(init);[m
[32m+[m[32m          break;[m
[32m+[m[41m           [m
[32m+[m[32m        case 1:[m
[32m+[m[32m          //sound fun with notes[m
[32m+[m[32m          this->modeSoundNotes();[m
[32m+[m[32m          break;[m
[32m+[m[41m           [m
[32m+[m[32m        case 2:[m
[32m+[m[32m          //sound fun with frequencies.[m
       #ifdef SIMON_APP[m
[31m-		  this->modeSimon(init);[m
[32m+[m[32m          this->modeSimon(init);[m
       #endif[m
[31m-		  break;[m
[31m-		  [m
[31m-		case 3:[m
[31m-		  //this->modeScroll(init);[m
[32m+[m[32m          break;[m
[32m+[m[41m           [m
[32m+[m[32m        case 3:[m
[32m+[m[32m          //this->modeScroll(init);[m
       this->modeDiceRoll(init);[m
[31m-		  break;[m
[31m-		  [m
[31m-		case 4:[m
[31m-		  this->modeGeiger(init);[m
[31m-		  break;[m
[31m-		  [m
[31m-		case 5:[m
[31m-		  this->modeSoundSong(init);[m
[31m-		  break;[m
[31m-		  [m
[31m-		case 6:[m
[31m-		  this->draw(init);[m
[31m-		  break;[m
[31m-		  [m
[31m-		case 7:[m
[32m+[m[32m          break;[m
[32m+[m[41m           [m
[32m+[m[32m        case 4:[m
[32m+[m[32m          this->modeGeiger(init);[m
[32m+[m[32m          break;[m
[32m+[m[41m           [m
[32m+[m[32m        case 5:[m
[32m+[m[32m          this->modeSoundSong(init);[m
[32m+[m[32m          break;[m
[32m+[m[41m           [m
[32m+[m[32m        case 6:[m
[32m+[m[32m          this->draw(init);[m
[32m+[m[32m          break;[m
[32m+[m[41m           [m
[32m+[m[32m        case 7:[m
       this->modeSimpleButtonsAndLights(init);    [m
[31m-		  break;[m
[31m-		  [m
[31m-		case 8:[m
[31m-		  this->modeSequencer(init);[m
[31m-		  break;[m
[31m-		  [m
[31m-		case 9:[m
[32m+[m[32m          break;[m
[32m+[m[41m           [m
[32m+[m[32m        case 8:[m
[32m+[m[32m          this->modeSequencer(init);[m
[32m+[m[32m          break;[m
[32m+[m[41m           [m
[32m+[m[32m        case 9:[m
       #ifdef ENABLE_REACTION_APP[m
[31m-		  this->modeReactionGame(init);[m
[32m+[m[32m          this->modeReactionGame(init);[m
       #endif[m
[31m-		  break;[m
[31m-		  [m
[31m-		case 10:[m
[31m-		  this->tiltSwitchTest(init);[m
[31m-		  break;[m
[31m-		  [m
[31m-		case 11:[m
[32m+[m[32m          break;[m
[32m+[m[41m           [m
[32m+[m[32m        case 10:[m
[32m+[m[32m          this->tiltSwitchTest(init);[m
[32m+[m[32m          break;[m
[32m+[m[41m           [m
[32m+[m[32m        case 11:[m
       #ifdef ENABLE_MULTITIMER[m
[31m-		  this->miniMultiTimer(init);[m
[32m+[m[32m          this->miniMultiTimer(init);[m
       #endif[m
[31m-		  break;[m
[31m-[m
[32m+[m[32m          break;[m
[32m+[m[41m [m
     #ifdef ENABLE_ANALOG_PIN_DEBUG[m
[31m-		case 12:[m
[32m+[m[32m        case 12:[m
       //this is the debug mode[m
       this->modeButtonDebug(init);[m
       break;[m
     #endif[m
[31m-		[m
[32m+[m[41m         [m
     default:[m
[31m-		  break;[m
[31m-		}[m
[31m-	}[m
[32m+[m[32m          break;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
 }[m
[31m-[m
[32m+[m[41m [m
 void Apps:: setDefaultMode(){[m
   //button lights[m
   ledDisp->SetLedArray(0b00000000);  // no lights[m
[31m-[m
[32m+[m[41m [m
   //display[m
   //ledDisp->SetFourDigits(0xC0C0C0C0); //default dispaly 4x minus and decimal point.[m
   //ledDisp->SetFourDigits(0x80808080); //default dispaly 4x minus[m
   ledDisp->setBlankDisplay();[m
   //ledDisp->SetFourDigits(0xC0C0C0C0); [m
   ledDisp->setBrightness(0,false);[m
[31m-  [m
[32m+[m[41m   [m
   //buzzer[m
   buzzer->setSpeedRatio(1);[m
   buzzer->buzzerOff(); // stop all sounds that were playing in an app. [m
   buzzer->setTranspose(0);[m
[31m-[m
[32m+[m[41m [m
 }[m
[31m-[m
[32m+[m[41m [m
 bool Apps::init_app(bool init, uint8_t selector){[m
[31m-	// shows splash screen[m
[31m-	[m
[31m-	if(init){[m
[31m-		// init of the init_app...[m
[31m-		this->displayAllSegments = 0;[m
[32m+[m[32m    // shows splash screen[m
[32m+[m[41m     [m
[32m+[m[32m    if(init){[m
[32m+[m[32m        // init of the init_app...[m
[32m+[m[32m        this->displayAllSegments = 0;[m
     for (uint8_t i=0;i<4;i++){[m
       this->displayAllSegments |= (uint32_t)pgm_read_byte_near(app_splash_screens + selector*4 + (i)) << (8*i); //* 4 --> 4 bytes per dword[m
     }[m
[31m-		[m
[32m+[m[41m         [m
     // initialize list[m
     for (uint8_t i = 0; i < bytes_list_bufsize; i++) {[m
[31m-     	this->FADE_IN_RANDOM_LIST[i] = i;[m
[32m+[m[32m        this->FADE_IN_RANDOM_LIST[i] = i;[m
     }[m
[31m-[m
[32m+[m[41m [m
     // // shuffle in place[m
     this->shuffle(this->FADE_IN_RANDOM_LIST, bytes_list_bufsize);[m
[31m-[m
[31m-		//this->fadeInList(step, bytes_list_bufsize, this->displayAllSegments, this->FADE_IN_RANDOM_LIST);[m
[31m-		// counter = 0;[m
[31m-		// this->TIMER_INIT_APP.setInitTimeMillis(-5); [m
[31m-[m
[31m-		counter = 27;[m
[31m-		this->TIMER_INIT_APP.setInitTimeMillis(-20); [m
[31m-[m
[31m-		this->TIMER_INIT_APP.start();[m
[31m-	}[m
[31m-	[m
[31m-	// advance one frame[m
[31m-	if(!this->TIMER_INIT_APP.getTimeIsNegative()){[m
[31m-		this->TIMER_INIT_APP.start();[m
[31m-		counter++;[m
[31m-	}[m
[31m-[m
[31m-	if (counter < 32){[m
[31m-		// ledDisp->SetFourDigits(displaySequence[31-counter]); // use fade in as fade out to set text.[m
[31m-		ledDisp->SetFourDigits(0xFFFFFFFF); // use fade in as fade out to set text.[m
[31m-[m
[31m-	}else if (counter < 50){[m
[31m-		ledDisp->SetFourDigits(this->displayAllSegments);[m
[31m-		// ledDisp->showNumber(selector);[m
[31m-		[m
[31m-	}else if (counter == 50){[m
[31m-		//this->fadeInList(displaySequence, 32, ~this->displayAllSegments);[m
[31m-		[m
[31m-	}else if (counter < 82 ){[m
[31m-		//ledDisp->SetFourDigits(~displaySequence[counter-51]);[m
[32m+[m[41m [m
[32m+[m[32m        //this->fadeInList(step, bytes_list_bufsize, this->displayAllSegments, this->FADE_IN_RANDOM_LIST);[m
[32m+[m[32m        // counter = 0;[m
[32m+[m[32m        // this->TIMER_INIT_APP.setInitTimeMillis(-5);[m[41m [m
[32m+[m[41m [m
[32m+[m[32m        counter = 27;[m
[32m+[m[32m        this->TIMER_INIT_APP.setInitTimeMillis(-20);[m[41m [m
[32m+[m[41m [m
[32m+[m[32m        this->TIMER_INIT_APP.start();[m
[32m+[m[32m    }[m
[32m+[m[41m     [m
[32m+[m[32m    // advance one frame[m
[32m+[m[32m    if(!this->TIMER_INIT_APP.getTimeIsNegative()){[m
[32m+[m[32m        this->TIMER_INIT_APP.start();[m
[32m+[m[32m        counter++;[m
[32m+[m[32m    }[m
[32m+[m[41m [m
[32m+[m[32m    if (counter < 32){[m
[32m+[m[32m        // ledDisp->SetFourDigits(displaySequence[31-counter]); // use fade in as fade out to set text.[m
[32m+[m[32m        ledDisp->SetFourDigits(0xFFFFFFFF); // use fade in as fade out to set text.[m
[32m+[m[41m [m
[32m+[m[32m    }else if (counter < 50){[m
[32m+[m[32m        ledDisp->SetFourDigits(this->displayAllSegments);[m
[32m+[m[32m        // ledDisp->showNumber(selector);[m
[32m+[m[41m         [m
[32m+[m[32m    }else if (counter == 50){[m
[32m+[m[32m        //this->fadeInList(displaySequence, 32, ~this->displayAllSegments);[m
[32m+[m[41m         [m
[32m+[m[32m    }else if (counter < 82 ){[m
[32m+[m[32m        //ledDisp->SetFourDigits(~displaySequence[counter-51]);[m
     ledDisp->SetFourDigits(~ this->fadeInList(counter-51, bytes_list_bufsize, ~this->displayAllSegments, this->FADE_IN_RANDOM_LIST)); [m
[31m-		[m
[31m-	}else {[m
[31m-		this->setDefaultMode();[m
[31m-		return true;[m
[31m-	}	  [m
[31m-	return false;[m
[32m+[m[41m         [m
[32m+[m[32m    }else {[m
[32m+[m[32m        this->setDefaultMode();[m
[32m+[m[32m        return true;[m
[32m+[m[32m    }[m[41m     [m
[32m+[m[32m    return false;[m
 }[m
[31m-[m
[32m+[m[41m [m
 void Apps::modeButtonDebug(bool init){[m
   // integrated debug mode (intended to be able to be activated in the final product in order to debug).[m
   // will show in sequence all analog input values.[m
[36m@@ -185,19 +185,19 @@[m [mvoid Apps::modeButtonDebug(bool init){[m
     generalTimer.start();[m
     counter = -1;[m
   }[m
[31m-  [m
[32m+[m[41m   [m
   if(!generalTimer.getTimeIsNegative()){[m
     // Serial.println("dbug displ");[m
     counter++;[m
     if (counter > 9){[m
        counter = 0; [m
     }[m
[31m-    [m
[32m+[m[41m     [m
     // Serial.println(counter);[m
     textBuf[1]=' ';[m
     textBuf[2]=' ';[m
     textBuf[3]='A'; [m
[31m-   [m
[32m+[m[41m    [m
     switch (counter){[m
       // case 0:{[m
       //   // textBuf[4]='0'; // analog A0[m
[36m@@ -255,83 +255,83 @@[m [mvoid Apps::modeButtonDebug(bool init){[m
         break; [m
       }[m
     }[m
[31m-[m
[32m+[m[41m [m
     // show menu title (compressed)[m
     if (counter%2 == 0){[m
       // show analog pin[m
       textBuf[4] = counter/2 + 48; // char 0 + analog pin . [m
       ledDisp->displayHandler(textBuf);[m
     }[m
[31m-[m
[32m+[m[41m [m
     // show values one seconds, menu items half a second[m
     generalTimer.setInitTimeMillis((long) (-500 - (counter%2)*500)); [m
[31m-    [m
[32m+[m[41m     [m
     generalTimer.start();[m
   }  [m
 }[m
[31m-[m
[32m+[m[41m [m
 void Apps::modeDiceRoll(bool init){[m
   if (init){[m
[31m-  [m
[32m+[m[41m   [m
     counter = 1;[m
     generalTimer.setInitTimeMillis(-1000);[m
[31m-  	generalTimer.start();[m
[32m+[m[32m    generalTimer.start();[m
   }[m
[31m-[m
[32m+[m[41m [m
   if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){[m
[31m-[m
[32m+[m[41m [m
     generalTimer.setInitTimeMillis((long)(1* potentio->getValueMapped(-1000, 0))); //divided by ten, this way, we can set the timer very accurately as displayed on screen when big red is pressed. *100ms[m
[31m-  [m
[32m+[m[41m   [m
   }else{[m
     generalTimer.setInitTimeMillis(-1000);[m
[31m-[m
[32m+[m[41m [m
   }[m
[31m-[m
[32m+[m[41m [m
   if (binaryInputs[BUTTON_MOMENTARY_2].getValue() || binaryInputs[BUTTON_MOMENTARY_0].getValue()|| binaryInputs[BUTTON_MOMENTARY_1].getValue()){[m
[31m-    [m
[32m+[m[41m     [m
     // DICEROLL_RANDOM_NUMBER ++;[m
     // if (DICEROLL_RANDOM_NUMBER > 6){  // NO THIS IS TERRIBLE! about 600 times per second cycling through, so, this is as good as random, or is it? can you time it and predict your roll? I'll leave it in for you to find out![m
     //   DICEROLL_RANDOM_NUMBER = 1;[m
     // }[m
     DICEROLL_RANDOM_NUMBER = random (1,7);[m
[31m-[m
[32m+[m[41m [m
     if (!generalTimer.getTimeIsNegative()){[m
[31m-[m
[32m+[m[41m [m
       if (binaryInputs[BUTTON_MOMENTARY_1].getValue()){   [m
[31m-        [m
[32m+[m[41m         [m
         for (uint8_t  i=1;i<4;i++){[m
           textBuf[i]=textBuf[i+1];[m
         }[m
         textBuf[4] = 48 + DICEROLL_RANDOM_NUMBER; // convert digit to number char.[m
       }[m
[31m-[m
[32m+[m[41m [m
       buzzer->cleanBuzzerRoll();[m
       buzzer->programBuzzerRoll(14);[m
       ledDisp->displayHandler(textBuf);[m
       generalTimer.start();[m
     }[m
[31m-[m
[32m+[m[41m [m
     if (binaryInputs[BUTTON_MOMENTARY_2].getValue()){[m
       // show random nonsense coolness. [m
[31m-      [m
[32m+[m[41m       [m
       textBuf[1]='?';[m
       textBuf[2]='?';[m
       textBuf[3]='?'; [m
       textBuf[4]='?'; [m
[31m-[m
[32m+[m[41m [m
     } else if (binaryInputs[BUTTON_MOMENTARY_1].getValue()){[m
       // sequence of numbers[m
[31m-      [m
[32m+[m[41m       [m
     }else{[m
       // show dice eyes[m
[31m-      [m
[32m+[m[41m       [m
       textBuf[4] = ' '; [m
       for (uint8_t i=1;i<4;i++){[m
         // build up dice eyes over three digits [m
[31m-[m
[32m+[m[41m [m
         //set default for digit 1 2 and 3. Because most used (seg A and D) [m
         textBuf[i] = '=';  [m
[31m-[m
[32m+[m[41m [m
         //first and third digit[m
         if (DICEROLL_RANDOM_NUMBER == 1){[m
           textBuf[i] = ' '; // [m
[36m@@ -341,7 +341,7 @@[m [mvoid Apps::modeDiceRoll(bool init){[m
             textBuf[i] = '_'; // seg D[m
           }[m
         }[m
[31m-[m
[32m+[m[41m [m
         //second digit[m
         if (i == 2 && DICEROLL_RANDOM_NUMBER < 6){[m
           textBuf[i] = '-'; // assume odd[m
[36m@@ -352,13 +352,13 @@[m [mvoid Apps::modeDiceRoll(bool init){[m
       }[m
     }[m
   } [m
[31m-  [m
[32m+[m[41m   [m
 }[m
[31m-[m
[32m+[m[41m [m
 // void Apps::modeScroll(bool init){[m
[31m-  [m
[32m+[m[41m   [m
 //   // display scroll mode[m
[31m-  [m
[32m+[m[41m   [m
 //   if (init){[m
 //     // display scroll mode[m
 // //    scrollBuf[0]='L';[m
[36m@@ -372,7 +372,7 @@[m [mvoid Apps::modeDiceRoll(bool init){[m
 // //    scrollBuf[8]='B';[m
 // //    scrollBuf[9]='Y';[m
 // //[m
[31m-[m
[32m+[m[41m [m
 //     this->scrollBuf[0]='H';[m
 //     scrollBuf[1]='A';[m
 //     scrollBuf[2]='P';[m
[36m@@ -392,64 +392,64 @@[m [mvoid Apps::modeDiceRoll(bool init){[m
 //     scrollBuf[16]='Y';[m
 //     //scrollBuf[10]='/0';[m
 //     ledDisp->dispHandlerWithScroll(scrollBuf, true, false);[m
[31m-      [m
[31m-	  [m
[31m-// 	this->fadeInList(displaySequence, 32, 0);[m
[31m-// 	counter = 0;[m
[31m-// 	counter2= false;[m
[31m-	[m
[31m-// 	generalTimer.setInitTimeMillis(-200);[m
[31m-// 	generalTimer.start();[m
[32m+[m[41m       [m
[32m+[m[41m       [m
[32m+[m[32m//  this->fadeInList(displaySequence, 32, 0);[m
[32m+[m[32m//  counter = 0;[m
[32m+[m[32m//  counter2= false;[m
[32m+[m[41m     [m
[32m+[m[32m//  generalTimer.setInitTimeMillis(-200);[m
[32m+[m[32m//  generalTimer.start();[m
 //   }[m
 //   if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){[m
[31m-// 		  if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
[31m-// 			counter++;[m
[31m-			[m
[31m-// 			// Serial.println(displaySequence[counter], BIN);[m
[31m-// 		  }[m
[31m-// 		  if(!generalTimer.getTimeIsNegative()){[m
[31m-// 			  generalTimer.start();[m
[31m-// 			  counter++;[m
[31m-// 		  }[m
[31m-// 		  if (counter>31){[m
[31m-// 				counter = 0;[m
[31m-// 				this->fadeInList(displaySequence, 32, 0);[m
[31m-// 				counter2  = !counter2;[m
[31m-// 			}[m
[31m-			[m
[31m-// 		  if (potentio->getValueStableChangedEdge()){[m
[31m-// 			generalTimer.setInitTimeMillis((long)( potentio->getValueMapped(-1000, 0))); //divided by ten, this way, we can set the timer very accurately as displayed on screen when big red is pressed. *100ms[m
[31m-// 		  }[m
[31m-		  [m
[31m-// 		  displayAllSegments = displaySequence[counter];[m
[31m-// 		  if (counter2){[m
[31m-// 			  // negative ==> which makes it fade out.[m
[31m-// 			  displayAllSegments = ~displayAllSegments;[m
[31m-// 		  }[m
[31m-			  [m
[31m-// 		  ledDisp->SetFourDigits(displayAllSegments);[m
[31m-[m
[31m-		 [m
[31m-// 	  }else{[m
[31m-// 		  if (!binaryInputs[BUTTON_MOMENTARY_2].getValue()){[m
[31m-// 			ledDisp->doScroll();[m
[31m-// 		  }[m
[31m-[m
[31m-// 		  if (binaryInputs[BUTTON_LATCHING_BIG_RED].getValue()){[m
[31m-// 			ledDisp->setScrollSpeed((long)potentio->getValueStable());[m
[31m-// 		  }else{[m
[31m-// 			ledDisp->setBrightness((byte)(potentio->getValueMapped(0,50)),false);[m
[31m-// 		  }[m
[31m-// 	  }[m
[31m-  [m
[32m+[m[32m//        if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
[32m+[m[32m//          counter++;[m
[32m+[m[41m             [m
[32m+[m[32m//          // Serial.println(displaySequence[counter], BIN);[m
[32m+[m[32m//        }[m
[32m+[m[32m//        if(!generalTimer.getTimeIsNegative()){[m
[32m+[m[32m//            generalTimer.start();[m
[32m+[m[32m//            counter++;[m
[32m+[m[32m//        }[m
[32m+[m[32m//        if (counter>31){[m
[32m+[m[32m//              counter = 0;[m
[32m+[m[32m//              this->fadeInList(displaySequence, 32, 0);[m
[32m+[m[32m//              counter2  = !counter2;[m
[32m+[m[32m//          }[m
[32m+[m[41m             [m
[32m+[m[32m//        if (potentio->getValueStableChangedEdge()){[m
[32m+[m[32m//          generalTimer.setInitTimeMillis((long)( potentio->getValueMapped(-1000, 0))); //divided by ten, this way, we can set the timer very accurately as displayed on screen when big red is pressed. *100ms[m
[32m+[m[32m//        }[m
[32m+[m[41m           [m
[32m+[m[32m//        displayAllSegments = displaySequence[counter];[m
[32m+[m[32m//        if (counter2){[m
[32m+[m[32m//            // negative ==> which makes it fade out.[m
[32m+[m[32m//            displayAllSegments = ~displayAllSegments;[m
[32m+[m[32m//        }[m
[32m+[m[41m               [m
[32m+[m[32m//        ledDisp->SetFourDigits(displayAllSegments);[m
[32m+[m[41m [m
[32m+[m[41m          [m
[32m+[m[32m//    }else{[m
[32m+[m[32m//        if (!binaryInputs[BUTTON_MOMENTARY_2].getValue()){[m
[32m+[m[32m//          ledDisp->doScroll();[m
[32m+[m[32m//        }[m
[32m+[m[41m [m
[32m+[m[32m//        if (binaryInputs[BUTTON_LATCHING_BIG_RED].getValue()){[m
[32m+[m[32m//          ledDisp->setScrollSpeed((long)potentio->getValueStable());[m
[32m+[m[32m//        }else{[m
[32m+[m[32m//          ledDisp->setBrightness((byte)(potentio->getValueMapped(0,50)),false);[m
[32m+[m[32m//        }[m
[32m+[m[32m//    }[m
[32m+[m[41m   [m
 // }[m
[31m-[m
[32m+[m[41m [m
 void Apps::modeSimpleButtonsAndLights(bool init){[m
   lights = 0b00000000; //reset before switch enquiry[m
[31m-[m
[32m+[m[41m [m
   if (init){[m
     SETTINGS_MODE_SELECTOR = 0;[m
[31m-[m
[32m+[m[41m [m
     if(  analogRead(PIN_BUTTONS_1) == 0 &&[m
           analogRead(PIN_BUTTONS_2) == 0 &&[m
           analogRead(PIN_POTENTIO) == 0){[m
[36m@@ -459,35 +459,35 @@[m [mvoid Apps::modeSimpleButtonsAndLights(bool init){[m
           SETTINGS_MODE_DISPLAY_VALUES_BLINK.start();[m
     }  [m
   }[m
[31m-[m
[32m+[m[41m [m
   // back and forth motion required of the potentio to count up modes[m
   if (potentio->getValue() < 5 && SETTINGS_MODE_SELECTOR % 2 ==0){[m
     SETTINGS_MODE_SELECTOR++;[m
   }else if (potentio->getValue() >1000 && SETTINGS_MODE_SELECTOR % 2 !=0){[m
     SETTINGS_MODE_SELECTOR++;[m
   }[m
[31m-[m
[32m+[m[41m [m
     textBuf[1]=' ';[m
     textBuf[2]=' ';[m
     textBuf[3]=' '; [m
     textBuf[4]=' '; [m
[31m-   [m
[31m-  if (SETTINGS_MODE_SELECTOR < 6){[m
     [m
[32m+[m[32m  if (SETTINGS_MODE_SELECTOR < 6){[m
[32m+[m[41m     [m
       //normal mode[m
[31m-[m
[32m+[m[41m [m
       // simple repetitive, predictive mode.[m
       // each button triggers its corresponding light. [m
       // potentio sets display brightness[m
       // no buzzer[m
       // display lights up a segment for each button.[m
[31m-[m
[32m+[m[41m [m
       bool updateScreen = false;[m
[31m-[m
[32m+[m[41m [m
       //delete all content from screen.[m
       ledDisp->setBlankDisplay();      [m
[31m-      [m
[31m-      [m
[32m+[m[41m       [m
[32m+[m[41m       [m
       if (binaryInputs[BUTTON_MOMENTARY_0].getValue()){[m
         lights|= 1<<LIGHT_RED;[m
         updateScreen = true;[m
[36m@@ -503,7 +503,7 @@[m [mvoid Apps::modeSimpleButtonsAndLights(bool init){[m
         updateScreen = true;[m
         SETTINGS_MODE_SELECTOR = 0;[m
       }[m
[31m-      [m
[32m+[m[41m       [m
       #if MOMENTARY_BUTTONS_COUNT == 4[m
       if (binaryInputs[BUTTON_MOMENTARY_3].getValue()){[m
         lights|= 1<<LIGHT_YELLOW_EXTRA;[m
[36m@@ -511,7 +511,7 @@[m [mvoid Apps::modeSimpleButtonsAndLights(bool init){[m
         SETTINGS_MODE_SELECTOR = 0;[m
       }[m
       #endif[m
[31m-[m
[32m+[m[41m [m
       if (updateScreen){[m
         textBuf[1]='8';[m
         textBuf[2]='8';[m
[36m@@ -524,7 +524,7 @@[m [mvoid Apps::modeSimpleButtonsAndLights(bool init){[m
         textBuf[3]='-';[m
         textBuf[4]='-';[m
       }[m
[31m-[m
[32m+[m[41m [m
       if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){[m
         lights|= 1<<LIGHT_LED_1;[m
       }else{[m
[36m@@ -547,40 +547,40 @@[m [mvoid Apps::modeSimpleButtonsAndLights(bool init){[m
       }else{[m
         textBuf[4]=' ';[m
       }[m
[31m-[m
[32m+[m[41m [m
       ledDisp->displayHandler(textBuf);[m
[32m+[m[41m       [m
       [m
[31m-     [m
       ledDisp->setBrightness((byte)(50 - potentio->getValueMapped(0,50)),false);[m
[31m-[m
[32m+[m[41m [m
     }else if (SETTINGS_MODE_SELECTOR < 8){[m
       lights|= 1<<LIGHT_RED;[m
       if(binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m
        #ifdef ENABLE_EEPROM[m
[31m-        [m
[32m+[m[41m         [m
         eeprom_update_byte([m
           (uint8_t*)EEPROM_SOUND_OFF_BY_DEFAULT,[m
           //i,[m
           !eeprom_read_byte((uint8_t*)EEPROM_SOUND_OFF_BY_DEFAULT)[m
         );[m
         #endif[m
[31m-      [m
[32m+[m[41m       [m
         if (buzzer->getPin() == PIN_BUZZER){[m
           buzzer->setPin(PIN_BUZZER_FAKE);[m
         }else{[m
           buzzer->setPin(PIN_BUZZER);[m
         }[m
       }[m
[31m-[m
[32m+[m[41m [m
       if (SETTINGS_MODE_DISPLAY_VALUES_BLINK.getInFirstGivenHundredsPartOfSecond(500)){[m
         textBuf[1]='B'; [m
         textBuf[2]='E'; [m
         textBuf[3]='E'; [m
         textBuf[4]='P'; [m
[31m-[m
[32m+[m[41m [m
       }else{[m
         textBuf[2]='O'; // On Off o char[m
[31m-        [m
[32m+[m[41m         [m
         if (buzzer->getPin() == PIN_BUZZER){[m
           //ON [m
           //textBuf[1]=' '; [m
[36m@@ -588,7 +588,7 @@[m [mvoid Apps::modeSimpleButtonsAndLights(bool init){[m
           // textBuf[4]=' ';[m
         }else{[m
           // OFF[m
[31m-[m
[32m+[m[41m [m
           // textBuf[1]=' '; [m
           // textBuf[2]='O'; [m
           textBuf[3]='F'; [m
[36m@@ -596,39 +596,39 @@[m [mvoid Apps::modeSimpleButtonsAndLights(bool init){[m
         } [m
         ledDisp->displayHandler(textBuf);[m
       }[m
[31m-      [m
[32m+[m[41m       [m
     }else if (SETTINGS_MODE_SELECTOR < 10){[m
       textBuf[3]='A'; [m
       textBuf[4]='0'; [m
       ledDisp->showNumber( (int16_t) analogRead(PIN_SELECTOR_DIAL)); [m
[31m-    [m
[32m+[m[41m     [m
     }else if (SETTINGS_MODE_SELECTOR < 12){[m
       textBuf[3]='A'; [m
       textBuf[4]='1'; [m
       ledDisp->showNumber( (int16_t) analogRead(PIN_BUTTONS_1)); [m
[31m-    [m
[32m+[m[41m     [m
     }else if (SETTINGS_MODE_SELECTOR < 14){[m
       textBuf[3]='A'; [m
       textBuf[4]='2'; [m
       ledDisp->showNumber( (int16_t) analogRead(PIN_BUTTONS_2));[m
[31m-    [m
[32m+[m[41m     [m
     }else if (SETTINGS_MODE_SELECTOR < 16){[m
       textBuf[3]='A'; [m
       textBuf[4]='3'; [m
       ledDisp->showNumber( (int16_t) analogRead(PIN_POTENTIO));[m
[31m-[m
[32m+[m[41m [m
     }else if (SETTINGS_MODE_SELECTOR < 18){[m
       textBuf[3]='A'; [m
       textBuf[4]='4'; [m
       ledDisp->showNumber( (int16_t) analogRead(PIN_MERCURY_SWITCHES));[m
[31m-    [m
[32m+[m[41m     [m
     }else if (SETTINGS_MODE_SELECTOR < 20){[m
       if (SETTINGS_MODE_DISPLAY_VALUES_BLINK.getInFirstGivenHundredsPartOfSecond(300)){[m
         textBuf[1]='E'; [m
         textBuf[2]='E'; [m
         textBuf[3]='P'; [m
         textBuf[4]='R'; [m
[31m-[m
[32m+[m[41m [m
       }else{[m
         textBuf[1]='R'; [m
         textBuf[2]='S'; [m
[36m@@ -639,7 +639,7 @@[m [mvoid Apps::modeSimpleButtonsAndLights(bool init){[m
     }else if (SETTINGS_MODE_SELECTOR < 22){[m
       lights|= 1<<LIGHT_RED;[m
      if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m
[31m-        [m
[32m+[m[41m         [m
         #ifdef ENABLE_EEPROM[m
         for(uint16_t i = 0;i<100;i=i+2){[m
           eeprom_update_word([m
[36m@@ -653,66 +653,66 @@[m [mvoid Apps::modeSimpleButtonsAndLights(bool init){[m
         textBuf[2]='O'; [m
         textBuf[3]='N'; [m
         textBuf[4]='E'; [m
[31m-[m
[31m-[m
[32m+[m[41m [m
[32m+[m[41m [m
       }else{[m
         textBuf[1]='D'; [m
         textBuf[2]='O'; [m
         textBuf[3]='I'; [m
         textBuf[4]='T'; [m
         ledDisp->displayHandler(textBuf);[m
[31m-[m
[32m+[m[41m [m
       }[m
     }else if (SETTINGS_MODE_SELECTOR < 24){[m
[31m-    [m
[32m+[m[41m     [m
       ledDisp->showNumber(SETTINGS_MODE_SELECTOR);[m
[31m-[m
[31m-[m
[31m-[m
[32m+[m[41m [m
[32m+[m[41m [m
[32m+[m[41m [m
     }else{[m
       ledDisp->showNumber(SETTINGS_MODE_SELECTOR);[m
     }[m
[31m-[m
[31m-[m
[32m+[m[41m [m
[32m+[m[41m [m
     if (SETTINGS_MODE_SELECTOR >= 6){[m
       // in real settings mode[m
[31m-[m
[32m+[m[41m [m
       // show menu title (compressed)[m
       // if (counter%2 == 0){[m
       //   // show analog pin[m
       //   textBuf[4] = counter/2 + 48; // char 0 + analog pin . [m
       //   ledDisp->displayHandler(textBuf);[m
       // }[m
[31m-[m
[31m-      [m
[32m+[m[41m [m
[32m+[m[41m       [m
       if (SETTINGS_MODE_DISPLAY_VALUES_BLINK.getTimeIsNegative()){[m
         SETTINGS_MODE_DISPLAY_VALUES_BLINK.start();[m
       }[m
[31m-      [m
[32m+[m[41m       [m
       if (SETTINGS_MODE_DISPLAY_VALUES_BLINK.getInFirstGivenHundredsPartOfSecond(500)){[m
           ledDisp->displayHandler(textBuf);[m
       }[m
[31m-[m
[32m+[m[41m [m
       // show values one seconds, menu items half a second[m
       //generalTimer.setInitTimeMillis((long) (-500 - (counter%2)*500)); [m
[31m-     [m
[31m-[m
[32m+[m[41m      [m
[32m+[m[41m [m
     }[m
     ledDisp->SetLedArray(lights);[m
 }[m
[31m-[m
[32m+[m[41m [m
 void Apps::modeCountingLettersAndChars(bool init){[m
         //counting mode: numbers and letters.[m
       bool updateScreen = false;[m
[31m-[m
[32m+[m[41m [m
       if (init){[m
         updateScreen = true;[m
[31m-	     	generalTimer.setInitTimeMillis(-1000);[m
[32m+[m[32m            generalTimer.setInitTimeMillis(-1000);[m
       }[m
[31m-      [m
[32m+[m[41m       [m
       const bool numberElseAlphabethMode = !binaryInputs[BUTTON_LATCHING_EXTRA].getValue();[m
[31m-	  [m
[31m-  [m
[32m+[m[41m       [m
[32m+[m[41m   [m
       if (binaryInputs[BUTTON_LATCHING_EXTRA].getValueChanged()){[m
         updateScreen = true;[m
         if (!numberElseAlphabethMode){[m
[36m@@ -723,12 +723,12 @@[m [mvoid Apps::modeCountingLettersAndChars(bool init){[m
           buzzer->buzzerOff();[m
         }[m
       }[m
[31m-    [m
[32m+[m[41m     [m
       if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
         counter++;[m
         updateScreen = true;[m
       }[m
[31m-       [m
[32m+[m[41m        [m
       if (binaryInputs[BUTTON_MOMENTARY_1].getEdgeUp()){[m
         counter--;[m
         updateScreen = true;[m
[36m@@ -741,16 +741,16 @@[m [mvoid Apps::modeCountingLettersAndChars(bool init){[m
         }[m
         updateScreen = true;[m
       }[m
[31m-      [m
[31m-	  // auto count[m
[32m+[m[41m       [m
[32m+[m[32m      // auto count[m
       if (binaryInputs[BUTTON_LATCHING_BIG_RED].getEdgeUp()){[m
         generalTimer.start();[m
       }  [m
[31m-      [m
[31m-	  if (binaryInputs[BUTTON_LATCHING_BIG_RED].getEdgeDown()){[m
[32m+[m[41m       [m
[32m+[m[32m      if (binaryInputs[BUTTON_LATCHING_BIG_RED].getEdgeDown()){[m
         generalTimer.pause();        [m
       }  [m
[31m-	  [m
[32m+[m[41m       [m
       if (binaryInputs[BUTTON_LATCHING_BIG_RED].getValue() && !generalTimer.getTimeIsNegative()){[m
         if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){[m
           counter++;  [m
[36m@@ -760,17 +760,17 @@[m [mvoid Apps::modeCountingLettersAndChars(bool init){[m
         generalTimer.start();[m
         updateScreen = true;[m
       }[m
[31m-      [m
[32m+[m[41m       [m
       //potentio behaviour[m
       if (binaryInputs[BUTTON_LATCHING_BIG_RED].getValue()){[m
[31m-		if (potentio->getValueStableChangedEdge()){[m
[31m-			[m
[31m-			generalTimer.setInitTimeMillis((long)(100 * potentio->getValueMapped(-100, 0))); //divided by ten, this way, we can set the timer very accurately as displayed on screen when big red is pressed. *100ms[m
[31m-			generalTimer.start();[m
[31m-			ledDisp->showNumber( (int16_t)100 * (100 - potentio->getValueMapped(0,100)));[m
[31m-			[m
[31m-		}[m
[31m-	  }else if (binaryInputs[BUTTON_LATCHING_SMALL_RED_RIGHT].getValue()){[m
[32m+[m[32m        if (potentio->getValueStableChangedEdge()){[m
[32m+[m[41m             [m
[32m+[m[32m            generalTimer.setInitTimeMillis((long)(100 * potentio->getValueMapped(-100, 0))); //divided by ten, this way, we can set the timer very accurately as displayed on screen when big red is pressed. *100ms[m
[32m+[m[32m            generalTimer.start();[m
[32m+[m[32m            ledDisp->showNumber( (int16_t)100 * (100 - potentio->getValueMapped(0,100)));[m
[32m+[m[41m             [m
[32m+[m[32m        }[m
[32m+[m[32m      }else if (binaryInputs[BUTTON_LATCHING_SMALL_RED_RIGHT].getValue()){[m
         if (numberElseAlphabethMode){[m
           counter = (int16_t)(potentio->getValueMapped(0,100));[m
         }else{[m
[36m@@ -778,7 +778,7 @@[m [mvoid Apps::modeCountingLettersAndChars(bool init){[m
         }[m
         updateScreen = true;[m
       }[m
[31m-      [m
[32m+[m[41m       [m
       //only do the characters of the alphabet in lettermode.[m
       if (!numberElseAlphabethMode){[m
         if (counter > 26){[m
[36m@@ -793,7 +793,7 @@[m [mvoid Apps::modeCountingLettersAndChars(bool init){[m
           counter = 0;[m
         }[m
       }[m
[31m-[m
[32m+[m[41m [m
       if (updateScreen){[m
         // when potentio setting init time, it overrules the updateScreen and displays its value. updateScreen erases potentio value display..[m
         if (numberElseAlphabethMode){[m
[36m@@ -803,13 +803,13 @@[m [mvoid Apps::modeCountingLettersAndChars(bool init){[m
         }[m
       }[m
 }[m
[31m-[m
[32m+[m[41m [m
 void Apps::modeSoundSong(bool init){[m
   if (init){[m
     buzzer->loadBuzzerTrack(song_happy_dryer);[m
     buzzer->setSpeedRatio((float)2);[m
[31m-	}[m
[31m-[m
[32m+[m[32m    }[m
[32m+[m[41m [m
   if (potentio->getValueStableChangedEdge()){[m
     if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){[m
       buzzer->setTranspose((int8_t)(potentio->getValueMapped(-12,12)));[m
[36m@@ -817,7 +817,7 @@[m [mvoid Apps::modeSoundSong(bool init){[m
       buzzer->setSpeedRatio((float)(potentio->getValue()) / 256 );[m
     }[m
   }[m
[31m-  [m
[32m+[m[41m   [m
   if (binaryInputs[BUTTON_LATCHING_BIG_RED].getValue()){[m
     // advanced mode scales[m
     if (binaryInputs[BUTTON_LATCHING_EXTRA].getValue()){[m
[36m@@ -830,10 +830,12 @@[m [mvoid Apps::modeSoundSong(bool init){[m
       if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
         buzzer->loadBuzzerTrack(scale_major);[m
       }[m
[32m+[m[32m#ifdef BUTTON_MOMENTARY_3[m
       if (binaryInputs[BUTTON_MOMENTARY_3].getEdgeUp()){[m
         buzzer->loadBuzzerTrack(scale_pentatonic);[m
       }[m
[31m-[m
[32m+[m[32m#endif[m
[32m+[m[41m [m
     }else{[m
       if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m
         //buzzer->loadBuzzerTrack(song_retreat );[m
[36m@@ -844,10 +846,11 @@[m [mvoid Apps::modeSoundSong(bool init){[m
       if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
         buzzer->loadBuzzerTrack(scale_major_reversed);[m
       }[m
[32m+[m[32m#ifdef BUTTON_MOMENTARY_3[m
       if (binaryInputs[BUTTON_MOMENTARY_3].getEdgeUp()){[m
         // buzzer->loadBuzzerTrack(scale_pentatonic_reversed);[m
       }[m
[31m-      [m
[32m+[m[32m#endif[m
     }[m
   }else{[m
     // simple mode: songs![m
[36m@@ -871,19 +874,19 @@[m [mvoid Apps::modeSoundSong(bool init){[m
       if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
         buzzer->loadBuzzerTrack(song_happy_dryer);[m
       }[m
[31m-      [m
[32m+[m[41m       [m
     }[m
   }[m
 }[m
[31m-[m
[32m+[m[41m [m
 void Apps::modeSoundNotes(){[m
   //buzzer with buzzer roll (notes).[m
[31m-      [m
[32m+[m[41m       [m
   if (!binaryInputs[BUTTON_LATCHING_BIG_RED].getValue()){[m
[31m-    [m
[32m+[m[41m     [m
     // if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){  [m
       // if (potentio->getValueStableChangedEdge()){[m
[31m-      [m
[32m+[m[41m       [m
       // buzzer->buzzerOff();[m
         // SOUND_FUN_NOTE_INDEX = potentio->getValueMapped(0,255);[m
       // ledDisp->showNumber(SOUND_FUN_NOTE_INDEX);[m
[36m@@ -891,7 +894,7 @@[m [mvoid Apps::modeSoundNotes(){[m
       // }[m
     // }else  [m
     if (binaryInputs[BUTTON_LATCHING_SMALL_RED_RIGHT].getValue()){[m
[31m-      [m
[32m+[m[41m       [m
       if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m
         buzzer->buzzerOff();[m
         ledDisp->showNumber(buzzer->addRandomSoundToRoll(223, 235));[m
[36m@@ -906,7 +909,7 @@[m [mvoid Apps::modeSoundNotes(){[m
         ledDisp->showNumber(buzzer->addRandomSoundToRoll(97, 160));[m
       }  [m
     }else{ [m
[31m-[m
[32m+[m[41m [m
       // simple mode.[m
       if (potentio->getValueStableChangedEdge()){[m
         //buzzer->programBuzzerRoll(potentio->getValueStable() /4);;[m
[36m@@ -916,7 +919,7 @@[m [mvoid Apps::modeSoundNotes(){[m
       } [m
         buzzer->programBuzzerRoll(SOUND_FUN_NOTE_INDEX);[m
       }[m
[31m-        [m
[32m+[m[41m         [m
       if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m
         buzzer->programBuzzerRoll(SOUND_FUN_NOTE_INDEX);[m
         SOUND_FUN_NOTE_INDEX--;[m
[36m@@ -924,7 +927,7 @@[m [mvoid Apps::modeSoundNotes(){[m
       if (binaryInputs[BUTTON_MOMENTARY_1].getEdgeUp()){[m
         buzzer->programBuzzerRoll(SOUND_FUN_NOTE_INDEX);[m
       }[m
[31m-      [m
[32m+[m[41m       [m
       if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
         buzzer->programBuzzerRoll(SOUND_FUN_NOTE_INDEX);[m
         SOUND_FUN_NOTE_INDEX++;[m
[36m@@ -933,305 +936,305 @@[m [mvoid Apps::modeSoundNotes(){[m
     }[m
   }[m
 }[m
[31m-[m
[32m+[m[41m [m
 void Apps::draw(bool init){[m
[31m-	[m
[31m-	if(binaryInputs[BUTTON_LATCHING_BIG_RED].getEdgeUp()){[m
[31m-		this->movieAnimationMode(true);[m
[31m-		[m
[31m-	}else if (binaryInputs[BUTTON_LATCHING_BIG_RED].getEdgeDown()){[m
[31m-		this->modeSingleSegmentManipulation(false);[m
[31m-		[m
[31m-	}else if (binaryInputs[BUTTON_LATCHING_BIG_RED].getValue()){[m
[31m-		this->movieAnimationMode(init);[m
[31m-		[m
[31m-	}else{[m
[31m-		this->modeSingleSegmentManipulation(init);[m
[31m-	}[m
[32m+[m[41m     [m
[32m+[m[32m    if(binaryInputs[BUTTON_LATCHING_BIG_RED].getEdgeUp()){[m
[32m+[m[32m        this->movieAnimationMode(true);[m
[32m+[m[41m         [m
[32m+[m[32m    }else if (binaryInputs[BUTTON_LATCHING_BIG_RED].getEdgeDown()){[m
[32m+[m[32m        this->modeSingleSegmentManipulation(false);[m
[32m+[m[41m         [m
[32m+[m[32m    }else if (binaryInputs[BUTTON_LATCHING_BIG_RED].getValue()){[m
[32m+[m[32m        this->movieAnimationMode(init);[m
[32m+[m[41m         [m
[32m+[m[32m    }else{[m
[32m+[m[32m        this->modeSingleSegmentManipulation(init);[m
[32m+[m[32m    }[m
 }[m
[31m-[m
[32m+[m[41m [m
 void Apps::movieAnimationMode(bool init){[m
[31m-	//bool nextStep = 0;[m
[31m-	 //reset saved led disp state.[m
[31m-	if (init){[m
[31m-		counter = 4; // display is four characters. Four bytes.So, it should advance four bytes every step (default). But, it could give fun effects to change that number and see what happens... [m
[31m-		this->dataPlayer.loadAllData(disp_4digits_animations);[m
[31m-		this->dataPlayer.loadDataSet(1);[m
[31m-		this->dataPlayer.setAutoSteps(4);[m
[31m-	}[m
[31m-[m
[31m-	if (binaryInputs[BUTTON_LATCHING_EXTRA].getValue()){[m
[31m-		// manual mode[m
[31m-		if (potentio->getValueStableChangedEdge()){[m
[31m-			if (potentio->getLastStableValueChangedUp()){[m
[31m-				this->dataPlayer.setSetIndexDirection(1);[m
[31m-				this->dataPlayer.moveIndexSteps(counter);[m
[31m-			}else{[m
[31m-				this->dataPlayer.setSetIndexDirection(0);[m
[31m-				this->dataPlayer.moveIndexSteps(counter);[m
[31m-			}[m
[31m-		}[m
[31m-		[m
[31m-		if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){	[m
[31m-			 this->dataPlayer.setSetIndexDirection(1);[m
[31m-			 this->dataPlayer.moveIndexSteps(counter);[m
[31m-		}[m
[31m-		[m
[31m-		if (binaryInputs[BUTTON_MOMENTARY_1].getEdgeUp()){	[m
[31m-			counter++;[m
[31m-			if (counter>4){[m
[31m-				counter = 1;[m
[31m-			}[m
[31m-			this->dataPlayer.setAutoSteps(counter);[m
[31m-		}[m
[31m-		[m
[31m-		if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){	[m
[31m-			this->dataPlayer.setSetIndexDirection(0);[m
[31m-			 this->dataPlayer.moveIndexSteps(counter);[m
[31m-		}	[m
[31m-		[m
[31m-	}else{[m
[31m-		// auto mode.[m
[31m-		this->dataPlayer.update();[m
[31m-		if (potentio->getValueStableChangedEdge()){[m
[31m-			dataPlayer.setAutoStepSpeed(potentio->getValueMapped(-1024,0));[m
[31m-		}[m
[31m-[m
[31m-		if(binaryInputs[BUTTON_MOMENTARY_1].getEdgeUp()){[m
[31m-			this->dataPlayer.setSetIndexDirection(2);[m
[31m-		}[m
[31m-		  [m
[31m-		  // if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){[m
[31m-			// if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){	[m
[31m-			 // animation_step = (uint16_t)(counter/4) - 1; // last step[m
[31m-			// }[m
[31m-			// if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){	[m
[31m-				 // animation_step = 0; // first step[m
[31m-			// }[m
[31m-		  // }[m
[31m-		  [m
[31m-		  if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp() || binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m
[31m-		[m
[31m-			if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m
[31m-				this->dataPlayer.nextDataSet(false);[m
[31m-			}[m
[31m-			if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
[31m-				this->dataPlayer.nextDataSet(true);[m
[31m-			}[m
[31m-		}[m
[31m-	}[m
[31m-	[m
[31m-	// get the display data.[m
[31m-	displayAllSegments = this->dataPlayer.getActive32bit();[m
[31m-	[m
[31m-	//invert all data in picture [m
[31m-	if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){[m
[31m-	  // negative .[m
[31m-	  displayAllSegments = ~displayAllSegments ;[m
[31m-	}[m
[31m-	[m
[31m-	// set to display [m
[31m-	ledDisp->SetFourDigits(displayAllSegments);[m
[32m+[m[32m    //bool nextStep = 0;[m
[32m+[m[32m     //reset saved led disp state.[m
[32m+[m[32m    if (init){[m
[32m+[m[32m        counter = 4; // display is four characters. Four bytes.So, it should advance four bytes every step (default). But, it could give fun effects to change that number and see what happens...[m[41m [m
[32m+[m[32m        this->dataPlayer.loadAllData(disp_4digits_animations);[m
[32m+[m[32m        this->dataPlayer.loadDataSet(1);[m
[32m+[m[32m        this->dataPlayer.setAutoSteps(4);[m
[32m+[m[32m    }[m
[32m+[m[41m [m
[32m+[m[32m    if (binaryInputs[BUTTON_LATCHING_EXTRA].getValue()){[m
[32m+[m[32m        // manual mode[m
[32m+[m[32m        if (potentio->getValueStableChangedEdge()){[m
[32m+[m[32m            if (potentio->getLastStableValueChangedUp()){[m
[32m+[m[32m                this->dataPlayer.setSetIndexDirection(1);[m
[32m+[m[32m                this->dataPlayer.moveIndexSteps(counter);[m
[32m+[m[32m            }else{[m
[32m+[m[32m                this->dataPlayer.setSetIndexDirection(0);[m
[32m+[m[32m                this->dataPlayer.moveIndexSteps(counter);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[41m         [m
[32m+[m[32m        if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m[41m  [m
[32m+[m[32m             this->dataPlayer.setSetIndexDirection(1);[m
[32m+[m[32m             this->dataPlayer.moveIndexSteps(counter);[m
[32m+[m[32m        }[m
[32m+[m[41m         [m
[32m+[m[32m        if (binaryInputs[BUTTON_MOMENTARY_1].getEdgeUp()){[m[41m  [m
[32m+[m[32m            counter++;[m
[32m+[m[32m            if (counter>4){[m
[32m+[m[32m                counter = 1;[m
[32m+[m[32m            }[m
[32m+[m[32m            this->dataPlayer.setAutoSteps(counter);[m
[32m+[m[32m        }[m
[32m+[m[41m         [m
[32m+[m[32m        if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m[41m  [m
[32m+[m[32m            this->dataPlayer.setSetIndexDirection(0);[m
[32m+[m[32m             this->dataPlayer.moveIndexSteps(counter);[m
[32m+[m[32m        }[m[41m   [m
[32m+[m[41m         [m
[32m+[m[32m    }else{[m
[32m+[m[32m        // auto mode.[m
[32m+[m[32m        this->dataPlayer.update();[m
[32m+[m[32m        if (potentio->getValueStableChangedEdge()){[m
[32m+[m[32m            dataPlayer.setAutoStepSpeed(potentio->getValueMapped(-1024,0));[m
[32m+[m[32m        }[m
[32m+[m[41m [m
[32m+[m[32m        if(binaryInputs[BUTTON_MOMENTARY_1].getEdgeUp()){[m
[32m+[m[32m            this->dataPlayer.setSetIndexDirection(2);[m
[32m+[m[32m        }[m
[32m+[m[41m           [m
[32m+[m[32m          // if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){[m
[32m+[m[32m            // if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m[41m   [m
[32m+[m[32m             // animation_step = (uint16_t)(counter/4) - 1; // last step[m
[32m+[m[32m            // }[m
[32m+[m[32m            // if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m[41m   [m
[32m+[m[32m                 // animation_step = 0; // first step[m
[32m+[m[32m            // }[m
[32m+[m[32m          // }[m
[32m+[m[41m           [m
[32m+[m[32m          if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp() || binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m
[32m+[m[41m         [m
[32m+[m[32m            if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m
[32m+[m[32m                this->dataPlayer.nextDataSet(false);[m
[32m+[m[32m            }[m
[32m+[m[32m            if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
[32m+[m[32m                this->dataPlayer.nextDataSet(true);[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[41m     [m
[32m+[m[32m    // get the display data.[m
[32m+[m[32m    displayAllSegments = this->dataPlayer.getActive32bit();[m
[32m+[m[41m     [m
[32m+[m[32m    //invert all data in picture[m[41m [m
[32m+[m[32m    if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){[m
[32m+[m[32m      // negative .[m
[32m+[m[32m      displayAllSegments = ~displayAllSegments ;[m
[32m+[m[32m    }[m
[32m+[m[41m     [m
[32m+[m[32m    // set to display[m[41m [m
[32m+[m[32m    ledDisp->SetFourDigits(displayAllSegments);[m
 }[m
[31m-[m
[32m+[m[41m [m
 void Apps::modeSingleSegmentManipulation(bool init){[m
   uint8_t moveDir;[m
   moveDir = DO_NOTHING;[m
   if (init){[m
[31m-[m
[32m+[m[41m [m
     // animation_step = 0;[m
[31m-	[m
[32m+[m[41m     [m
     //bottom left is origin[m
     DRAW_X_POS = 0;[m
     DRAW_Y_POS = 0;[m
     DRAW_ACTIVE_SEGMENT = 0; // segment active[m
[31m-    [m
[32m+[m[41m     [m
     //reset saved led disp state.[m
     DRAW_DISP_STATE[0]=0;[m
     DRAW_DISP_STATE[1]=0;[m
     DRAW_DISP_STATE[2]=0;[m
     DRAW_DISP_STATE[3]=0;[m
[31m-    [m
[32m+[m[41m     [m
     //generalTimer.setInitTimeMillis(3000);[m
     //generalTimer.start();[m
   }[m
[31m-  [m
[32m+[m[41m   [m
   if (potentio->getValueStableChangedEdge()){[m
[31m-		  uint16_t val;[m
[31m-		  val = (uint16_t)potentio->getValueMapped(0,102); // 1024/10 causes no skips of segments. [m
[31m-		  val = val % 48;   // 48 positions for 3x4 matrix * 4 digits[m
[31m-		  DRAW_ACTIVE_SEGMENT = val/12; // get digit[m
[31m-		  val = val%12; [m
[31m-		  DRAW_X_POS = val/4; // get xpos[m
[31m-		  DRAW_Y_POS = val%4; // get ypos[m
[32m+[m[32m          uint16_t val;[m
[32m+[m[32m          val = (uint16_t)potentio->getValueMapped(0,102); // 1024/10 causes no skips of segments.[m[41m [m
[32m+[m[32m          val = val % 48;   // 48 positions for 3x4 matrix * 4 digits[m
[32m+[m[32m          DRAW_ACTIVE_SEGMENT = val/12; // get digit[m
[32m+[m[32m          val = val%12;[m[41m [m
[32m+[m[32m          DRAW_X_POS = val/4; // get xpos[m
[32m+[m[32m          DRAW_Y_POS = val%4; // get ypos[m
   }[m
[31m-  [m
[32m+[m[41m   [m
   if (binaryInputs[BUTTON_LATCHING_EXTRA].getValue()){[m
[31m-	  if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
[31m-		  moveDir = MOVE_RIGHT;[m
[31m-	  }[m
[31m-	  if (binaryInputs[BUTTON_MOMENTARY_1].getEdgeUp()){[m
[31m-		  moveDir = TOGGLE_SEGMENT;[m
[31m-	  }[m
[31m-	  if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){	[m
[31m-		  moveDir = MOVE_UP;[m
[31m-	  }[m
[32m+[m[32m      if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
[32m+[m[32m          moveDir = MOVE_RIGHT;[m
[32m+[m[32m      }[m
[32m+[m[32m      if (binaryInputs[BUTTON_MOMENTARY_1].getEdgeUp()){[m
[32m+[m[32m          moveDir = TOGGLE_SEGMENT;[m
[32m+[m[32m      }[m
[32m+[m[32m      if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m[41m    [m
[32m+[m[32m          moveDir = MOVE_UP;[m
[32m+[m[32m      }[m
   }else{[m
[31m-	  if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
[31m-		  moveDir = MOVE_RIGHT;[m
[31m-	  }[m
[31m-	  if (binaryInputs[BUTTON_MOMENTARY_1].getEdgeUp()){[m
[31m-		  moveDir = MOVE_LEFT;[m
[31m-	  }[m
[31m-	  if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){	[m
[31m-		  moveDir = MOVE_UP;[m
[31m-	  }[m
[32m+[m[32m      if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
[32m+[m[32m          moveDir = MOVE_RIGHT;[m
[32m+[m[32m      }[m
[32m+[m[32m      if (binaryInputs[BUTTON_MOMENTARY_1].getEdgeUp()){[m
[32m+[m[32m          moveDir = MOVE_LEFT;[m
[32m+[m[32m      }[m
[32m+[m[32m      if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m[41m    [m
[32m+[m[32m          moveDir = MOVE_UP;[m
[32m+[m[32m      }[m
   }[m
[31m-  [m
[32m+[m[41m   [m
   // set x and y coords[m
   // 3 (x) * 4(y) matrix. (y is 4 positions to "remember" if low or high part when passing through segment G)[m
   switch(moveDir){[m
[31m-	[m
[31m-	case MOVE_RIGHT:{[m
[31m-	  //move right[m
[31m-	  DRAW_X_POS++;[m
[31m-	  if (DRAW_X_POS > 2){[m
[31m-		  DRAW_ACTIVE_SEGMENT++; // next digit[m
[31m-		  if (DRAW_ACTIVE_SEGMENT> 3){ [m
[31m-			  DRAW_ACTIVE_SEGMENT = 0;[m
[31m-		  }[m
[31m-		  DRAW_X_POS = 0;[m
[31m-	  }[m
[31m-	}[m
[31m-	break;[m
[31m-	[m
[31m-	case MOVE_DOWN:[m
[31m-	{[m
[31m-	  //move down[m
[31m-	  switch (DRAW_Y_POS){[m
[31m-		case 0:[m
[31m-			DRAW_Y_POS = 3;[m
[31m-			break;[m
[31m-		case 1:[m
[31m-			DRAW_Y_POS = 0;[m
[31m-			break;[m
[31m-		case 2:[m
[31m-			DRAW_Y_POS = 0;[m
[31m-			break;[m
[31m-		case 3:[m
[31m-			DRAW_Y_POS = (DRAW_X_POS == 1)?2:0;[m
[31m-			break;[m
[31m-	  }	[m
[31m-	}[m
[31m-	break;[m
[31m-[m
[31m-	case MOVE_UP:[m
[31m-	{	[m
[31m-	  //move up[m
[31m-	   switch (DRAW_Y_POS){[m
[31m-		case 0:[m
[31m-			DRAW_Y_POS = (DRAW_X_POS == 1)?1:3;[m
[31m-			break;[m
[31m-		case 1:[m
[31m-			DRAW_Y_POS = 3;[m
[31m-			break;[m
[31m-		case 2:[m
[31m-			DRAW_Y_POS = 3;[m
[31m-			break;[m
[31m-		case 3:[m
[31m-			DRAW_Y_POS = 0;[m
[31m-			break;[m
[31m-	  }[m
[32m+[m[41m     [m
[32m+[m[32m    case MOVE_RIGHT:{[m
[32m+[m[32m      //move right[m
[32m+[m[32m      DRAW_X_POS++;[m
[32m+[m[32m      if (DRAW_X_POS > 2){[m
[32m+[m[32m          DRAW_ACTIVE_SEGMENT++; // next digit[m
[32m+[m[32m          if (DRAW_ACTIVE_SEGMENT> 3){[m[41m [m
[32m+[m[32m              DRAW_ACTIVE_SEGMENT = 0;[m
[32m+[m[32m          }[m
[32m+[m[32m          DRAW_X_POS = 0;[m
[32m+[m[32m      }[m
     }[m
     break;[m
[31m-    [m
[32m+[m[41m     [m
[32m+[m[32m    case MOVE_DOWN:[m
[32m+[m[32m    {[m
[32m+[m[32m      //move down[m
[32m+[m[32m      switch (DRAW_Y_POS){[m
[32m+[m[32m        case 0:[m
[32m+[m[32m            DRAW_Y_POS = 3;[m
[32m+[m[32m            break;[m
[32m+[m[32m        case 1:[m
[32m+[m[32m            DRAW_Y_POS = 0;[m
[32m+[m[32m            break;[m
[32m+[m[32m        case 2:[m
[32m+[m[32m            DRAW_Y_POS = 0;[m
[32m+[m[32m            break;[m
[32m+[m[32m        case 3:[m
[32m+[m[32m            DRAW_Y_POS = (DRAW_X_POS == 1)?2:0;[m
[32m+[m[32m            break;[m
[32m+[m[32m      }[m[41m [m
[32m+[m[32m    }[m
[32m+[m[32m    break;[m
[32m+[m[41m [m
[32m+[m[32m    case MOVE_UP:[m
[32m+[m[32m    {[m[41m   [m
[32m+[m[32m      //move up[m
[32m+[m[32m       switch (DRAW_Y_POS){[m
[32m+[m[32m        case 0:[m
[32m+[m[32m            DRAW_Y_POS = (DRAW_X_POS == 1)?1:3;[m
[32m+[m[32m            break;[m
[32m+[m[32m        case 1:[m
[32m+[m[32m            DRAW_Y_POS = 3;[m
[32m+[m[32m            break;[m
[32m+[m[32m        case 2:[m
[32m+[m[32m            DRAW_Y_POS = 3;[m
[32m+[m[32m            break;[m
[32m+[m[32m        case 3:[m
[32m+[m[32m            DRAW_Y_POS = 0;[m
[32m+[m[32m            break;[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m    break;[m
[32m+[m[41m     [m
     case MOVE_LEFT:[m
     { [m
[31m-	  //move left[m
[31m-	  if (DRAW_X_POS == 0){[m
[31m-		DRAW_ACTIVE_SEGMENT = (DRAW_ACTIVE_SEGMENT == 0)?3:(DRAW_ACTIVE_SEGMENT-1); // previous digit[m
[31m-		DRAW_X_POS = 2;[m
[31m-	  }else{[m
[31m-		DRAW_X_POS--;[m
[31m-	  }[m
[31m-    }[m
[31m-	break;[m
[31m-	 [m
[31m-	default:[m
[32m+[m[32m      //move left[m
[32m+[m[32m      if (DRAW_X_POS == 0){[m
[32m+[m[32m        DRAW_ACTIVE_SEGMENT = (DRAW_ACTIVE_SEGMENT == 0)?3:(DRAW_ACTIVE_SEGMENT-1); // previous digit[m
[32m+[m[32m        DRAW_X_POS = 2;[m
[32m+[m[32m      }else{[m
[32m+[m[32m        DRAW_X_POS--;[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m    break;[m
[32m+[m[41m      [m
[32m+[m[32m    default:[m
       break;[m
   }[m
[31m-[m
[32m+[m[41m [m
   uint8_t seg;[m
[31m-[m
[32m+[m[41m [m
   switch (10*DRAW_Y_POS + DRAW_X_POS){[m
[31m-	  case 0:[m
[31m-	  case 10:[m
[31m-		seg = 0b00010000;  //E[m
[31m-	    break;[m
[31m-	  case 1:[m
[31m-		seg = 0b00001000;  //D[m
[31m-		break;[m
[31m-	  case 32:[m
[31m-	  case 22:[m
[31m-	    seg = 0b00000010;  //B[m
[31m-		break;[m
[31m-	  case 20:[m
[31m-	  case 30:[m
[31m-		seg = 0b00100000;  //F[m
[31m-		break;[m
[31m-	  case 12:[m
[31m-	  case 2:[m
[31m-		seg = 0b00000100;  //C[m
[31m-		break;[m
[31m-	  case 11:[m
[31m-	  case 21:[m
[31m-		seg = 0b01000000;  //G[m
[31m-		break;[m
[31m-	  case 31:[m
[31m-		seg = 0b00000001;  //A[m
[31m-		break;[m
[31m-	  default:[m
[31m-		seg = 0b01010101;[m
[31m-		break;[m
[32m+[m[32m      case 0:[m
[32m+[m[32m      case 10:[m
[32m+[m[32m        seg = 0b00010000;  //E[m
[32m+[m[32m        break;[m
[32m+[m[32m      case 1:[m
[32m+[m[32m        seg = 0b00001000;  //D[m
[32m+[m[32m        break;[m
[32m+[m[32m      case 32:[m
[32m+[m[32m      case 22:[m
[32m+[m[32m        seg = 0b00000010;  //B[m
[32m+[m[32m        break;[m
[32m+[m[32m      case 20:[m
[32m+[m[32m      case 30:[m
[32m+[m[32m        seg = 0b00100000;  //F[m
[32m+[m[32m        break;[m
[32m+[m[32m      case 12:[m
[32m+[m[32m      case 2:[m
[32m+[m[32m        seg = 0b00000100;  //C[m
[32m+[m[32m        break;[m
[32m+[m[32m      case 11:[m
[32m+[m[32m      case 21:[m
[32m+[m[32m        seg = 0b01000000;  //G[m
[32m+[m[32m        break;[m
[32m+[m[32m      case 31:[m
[32m+[m[32m        seg = 0b00000001;  //A[m
[32m+[m[32m        break;[m
[32m+[m[32m      default:[m
[32m+[m[32m        seg = 0b01010101;[m
[32m+[m[32m        break;[m
   }[m
[31m-  [m
[32m+[m[41m   [m
   // toggle active segment.[m
   if (moveDir == TOGGLE_SEGMENT){[m
[31m-	    // toggle segment with xor old^toggleval=new  [m
[31m-		//	toggleval==0: 0^0=0, 1^0=1 , [m
[31m-		//  toggleval==1: 1^1=0, 0^1=1[m
[31m-		DRAW_DISP_STATE[DRAW_ACTIVE_SEGMENT]  ^= seg; [m
[32m+[m[32m        // toggle segment with xor old^toggleval=new[m[41m  [m
[32m+[m[32m        //  toggleval==0: 0^0=0, 1^0=1 ,[m[41m [m
[32m+[m[32m        //  toggleval==1: 1^1=0, 0^1=1[m
[32m+[m[32m        DRAW_DISP_STATE[DRAW_ACTIVE_SEGMENT]  ^= seg;[m[41m [m
   }[m
[31m-  [m
[32m+[m[41m   [m
   //invert all data in picture [m
   if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValueChanged()){[m
     //i can typ whatever i want mlem mlem mlem[m
[31m-	  // negative .[m
[31m-	  for (uint8_t i=0;i<4;i++){[m
[31m-		  DRAW_DISP_STATE[i] = ~DRAW_DISP_STATE[i] ;[m
[31m-	  }  [m
[32m+[m[32m      // negative .[m
[32m+[m[32m      for (uint8_t i=0;i<4;i++){[m
[32m+[m[32m          DRAW_DISP_STATE[i] = ~DRAW_DISP_STATE[i] ;[m
[32m+[m[32m      }[m[41m  [m
   }[m
[31m-  [m
[31m-  [m
[32m+[m[41m   [m
[32m+[m[41m   [m
   // set display[m
   for (uint8_t i=0;i<4;i++){[m
[31m-	  ledDisp->SetSingleDigit(DRAW_DISP_STATE[i],i+1);  [m
[32m+[m[32m      ledDisp->SetSingleDigit(DRAW_DISP_STATE[i],i+1);[m[41m  [m
   }[m
[31m-[m
[32m+[m[41m [m
   //show active segment on display[m
   // if (generalTimer.getInFirstGivenHundredsPartOfSecond(500) || !binaryInputs[BUTTON_LATCHING_EXTRA].getValue()){[m
   if (millis()%250 > 125 || !binaryInputs[BUTTON_LATCHING_EXTRA].getValue()){[m
[31m-	ledDisp->SetSingleDigit(seg^DRAW_DISP_STATE[DRAW_ACTIVE_SEGMENT],DRAW_ACTIVE_SEGMENT+1); // XOR the seg with the segment saved value, so it shows negatively.  [m
[32m+[m[32m    ledDisp->SetSingleDigit(seg^DRAW_DISP_STATE[DRAW_ACTIVE_SEGMENT],DRAW_ACTIVE_SEGMENT+1); // XOR the seg with the segment saved value, so it shows negatively.[m[41m  [m
   }[m
   // else{[m
[31m-	  // //only show the saved state, no blinking of active segment. [m
[31m-	  // ledDisp->SetSingleDigit(DRAW_DISP_STATE[DRAW_ACTIVE_SEGMENT],DRAW_ACTIVE_SEGMENT+1);[m
[32m+[m[32m      // //only show the saved state, no blinking of active segment.[m[41m [m
[32m+[m[32m      // ledDisp->SetSingleDigit(DRAW_DISP_STATE[DRAW_ACTIVE_SEGMENT],DRAW_ACTIVE_SEGMENT+1);[m
   // }[m
[31m-  [m
[32m+[m[41m   [m
 // ledDisp->displayHandler(textBuf);  [m
 // ledDisp->SetSingleDigit(B11111111, 1);  [m
 // ledDisp->SetSingleDigit((uint8_t) (potentio->getValueStable()/4), 3);  [m
[31m-  [m
[32m+[m[41m   [m
   // if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
     // ledDisp->SetSingleDigit(pgm_read_byte_near(disp_digit_animate + animation_step),1);  [m
     // //ledDisp->SetSingleDigit(pgm_read_byte_near(disp_digit_animate_double + animation_step),2);  [m
[36m@@ -1240,19 +1243,19 @@[m [mvoid Apps::modeSingleSegmentManipulation(bool init){[m
      // (animation_step>=5)?animation_step=0:animation_step++;[m
   // }[m
 }[m
[31m-[m
[32m+[m[41m [m
 #ifdef ENABLE_MULTITIMER[m
 void Apps::miniMultiTimer(bool init){[m
   // every player: init time, time left, alive? [m
   // game: pause, player alive? ,fischertimer active?/time, random starter[m
[31m-[m
[32m+[m[41m [m
   if (init){[m
[31m-	  this->multiTimer.setBuzzer(this->buzzer);[m
[31m-	  this->multiTimer.init();[m
[32m+[m[32m      this->multiTimer.setBuzzer(this->buzzer);[m
[32m+[m[32m      this->multiTimer.init();[m
   }  [m
[31m-  [m
[32m+[m[41m   [m
   // TIMER BUTTONS[m
[31m-  [m
[32m+[m[41m   [m
   for (uint8_t i = 0; i<MAX_TIMERS_COUNT; i++){[m
     if (binaryInputs[buttons_momentary_indexed[i]].getEdgeUp()){[m
       this->multiTimer.playerButtonPressEdgeUp(i);[m
[36m@@ -1261,36 +1264,36 @@[m [mvoid Apps::miniMultiTimer(bool init){[m
       this->multiTimer.playerButtonPressEdgeDown(i);[m
     }[m
   }[m
[31m-[m
[32m+[m[41m [m
   // START STOP Button[m
   if (binaryInputs[BUTTON_LATCHING_BIG_RED].getEdgeUp()){[m
[31m-	  this->multiTimer.start();[m
[32m+[m[32m      this->multiTimer.start();[m
   }[m
   if (binaryInputs[BUTTON_LATCHING_BIG_RED].getEdgeDown()){[m
[31m-	  this->multiTimer.init();[m
[32m+[m[32m      this->multiTimer.init();[m
   }[m
[31m-  [m
[32m+[m[41m   [m
   // PAUSE Switch[m
   this->multiTimer.setStatePause(binaryInputs[BUTTON_LATCHING_EXTRA].getValue()); // do not only work on edge here, as latching switch can  be in any state.[m
[31m-  [m
[31m-  // # set number of timers SWITCH	[m
[32m+[m[41m   [m
[32m+[m[32m  // # set number of timers SWITCH[m[41m  [m
   this->multiTimer.setStateTimersCount(binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()); // do not only work on edge here, as latching switch can  be in any state.[m
[31m-  [m
[31m-  // set fischer timer SWITCH	[m
[32m+[m[41m   [m
[32m+[m[32m  // set fischer timer SWITCH[m[41m   [m
   this->multiTimer.setStateFischerTimer(binaryInputs[BUTTON_LATCHING_SMALL_RED_RIGHT].getValue()); // do not only work on edge here, as latching switch can  be in any state.[m
[31m-  [m
[32m+[m[41m   [m
   // THE DIAL[m
   if (potentio->getValueStableChangedEdge()){[m
[31m-	  // number of timers[m
[31m-[m
[32m+[m[32m      // number of timers[m
[32m+[m[41m [m
     #ifdef PROTOTYPE[m
     this->multiTimer.setTimersCount((uint8_t)potentio->getValueMapped(1,3));[m
     #else[m
[31m-	  this->multiTimer.setTimersCount((uint8_t)potentio->getValueMapped(1,MAX_TIMERS_COUNT));[m
[32m+[m[32m      this->multiTimer.setTimersCount((uint8_t)potentio->getValueMapped(1,MAX_TIMERS_COUNT));[m
     #endif[m
[31m-	  // convert value to predefined amount of seconds.[m
[31m-	  uint16_t seconds =  this->multiTimer.getIndexedTime(potentio->getValueMapped(0,91)); // 0 seconds to an hour[m
[31m-      [m
[32m+[m[32m      // convert value to predefined amount of seconds.[m
[32m+[m[32m      uint16_t seconds =  this->multiTimer.getIndexedTime(potentio->getValueMapped(0,91)); // 0 seconds to an hour[m
[32m+[m[41m       [m
     // pass through to multitimer app, it has to decide about validity.[m
     bool individualTimerSet = false;[m
     for (uint8_t i = 0; i<MAX_TIMERS_COUNT; i++){[m
[36m@@ -1302,18 +1305,18 @@[m [mvoid Apps::miniMultiTimer(bool init){[m
     if (!individualTimerSet){[m
       this->multiTimer.setAllInitCountDownTimeSecs(seconds);[m
     }[m
[31m-[m
[32m+[m[41m [m
     this->multiTimer.setFischerTimer(seconds);[m
   }[m
[31m-  [m
[32m+[m[41m   [m
   // UPDATE CYCLIC[m
   this->multiTimer.refresh();[m
[31m-  [m
[32m+[m[41m   [m
   uint8_t buttonLights;[m
[31m-  [m
[32m+[m[41m   [m
   uint8_t settingsLights;[m
   this->multiTimer.getDisplay(textBuf, &buttonLights, &settingsLights);[m
[31m-  [m
[32m+[m[41m   [m
   uint8_t lights=0b00000000;[m
   // timer buttons lights to real lights[m
   for(uint8_t i=0;i<4;i++){[m
[36m@@ -1321,108 +1324,108 @@[m [mvoid Apps::miniMultiTimer(bool init){[m
         lights |= 1<<lights_indexed[i+1];    [m
     }[m
   }[m
[31m-  [m
[32m+[m[41m   [m
   // settings light to real lights[m
   (LIGHT_PAUSE & settingsLights)? lights|= 1<<LIGHT_YELLOW:false;[m
   (LIGHT_PLAYING & settingsLights)? lights|= 1<<LIGHT_LED_3:false;[m
   (LIGHT_FISCHER & settingsLights)? lights|= 1<<LIGHT_LED_2:false;[m
   (LIGHT_SET_TIMERS_COUNT & settingsLights)? lights|= 1<<LIGHT_LED_1:false;[m
[31m-[m
[32m+[m[41m [m
   ledDisp->displayHandler(textBuf);[m
   ledDisp->SetLedArray(lights); [m
   ledDisp->setDecimalPoint(LIGHT_SECONDS_BLINKER & settingsLights ,2);[m
[31m-    [m
[32m+[m[41m     [m
 }[m
 #endif[m
[31m-[m
[32m+[m[41m [m
 void Apps::tiltSwitchTest(bool init){[m
   // four tilt switches are positioned as such that they are "ON" in rest position. [m
   uint32_t screen = 0;[m
   if (init){[m
[31m-	  textBuf[1]='T'; [m
[31m-	  textBuf[2]='I'; [m
[31m-	  textBuf[3]='L'; [m
[31m-	  textBuf[4]='T'; [m
[31m-	  counter = 0;[m
[31m-	  counter2 = 0; // counts progress in movement.[m
[31m-	  buzzer->setSpeedRatio(2.0);[m
[31m-	  [m
[31m-	  this->dataPlayer.loadAllData(disp_4digits_animations);[m
[31m-	 [m
[31m-	  this->dataPlayer.setAutoSteps(4);[m
[31m-	  this->dataPlayer.setAutoStep(true);[m
[31m-	  this->dataPlayer.setAutoStepSpeed(-30);[m
[32m+[m[32m      textBuf[1]='T';[m[41m [m
[32m+[m[32m      textBuf[2]='I';[m[41m [m
[32m+[m[32m      textBuf[3]='L';[m[41m [m
[32m+[m[32m      textBuf[4]='T';[m[41m [m
[32m+[m[32m      counter = 0;[m
[32m+[m[32m      counter2 = 0; // counts progress in movement.[m
[32m+[m[32m      buzzer->setSpeedRatio(2.0);[m
[32m+[m[41m       [m
[32m+[m[32m      this->dataPlayer.loadAllData(disp_4digits_animations);[m
[32m+[m[41m      [m
[32m+[m[32m      this->dataPlayer.setAutoSteps(4);[m
[32m+[m[32m      this->dataPlayer.setAutoStep(true);[m
[32m+[m[32m      this->dataPlayer.setAutoStepSpeed(-30);[m
   }[m
[31m-  [m
[32m+[m[41m   [m
   if (binaryInputs[BUTTON_LATCHING_BIG_RED].getValue()){[m
[31m-	  // movie for each gesture[m
[31m-	  [m
[32m+[m[32m      // movie for each gesture[m
[32m+[m[41m       [m
      if (binaryInputs[SWITCH_TILT_FORWARD].getEdgeDown()){[m
[31m-		 this->dataPlayer.loadDataSet(1);[m
[31m-		 this->dataPlayer.setSetIndexDirection(1);[m
[31m-	 }[m
[31m-	 if (binaryInputs[SWITCH_TILT_BACKWARD].getEdgeDown()){[m
[31m-		 this->dataPlayer.loadDataSet(1);[m
[31m-		 this->dataPlayer.setSetIndexDirection(0);[m
[31m-	 }[m
[31m-	 if (binaryInputs[SWITCH_TILT_LEFT].getEdgeDown()){[m
[31m-		 this->dataPlayer.loadDataSet(0);[m
[31m-		 this->dataPlayer.setSetIndexDirection(1);[m
[31m-	 }[m
[31m-	 if (binaryInputs[SWITCH_TILT_RIGHT].getEdgeDown()){[m
[31m-		 this->dataPlayer.loadDataSet(0);[m
[31m-		 this->dataPlayer.setSetIndexDirection(0);[m
[31m-	 }[m
[31m-	 this->dataPlayer.update();[m
[31m-	 screen = this->dataPlayer.getActive32bit();[m
[31m-[m
[31m-	 ledDisp->SetFourDigits(screen);  [m
[31m-[m
[32m+[m[32m         this->dataPlayer.loadDataSet(1);[m
[32m+[m[32m         this->dataPlayer.setSetIndexDirection(1);[m
[32m+[m[32m     }[m
[32m+[m[32m     if (binaryInputs[SWITCH_TILT_BACKWARD].getEdgeDown()){[m
[32m+[m[32m         this->dataPlayer.loadDataSet(1);[m
[32m+[m[32m         this->dataPlayer.setSetIndexDirection(0);[m
[32m+[m[32m     }[m
[32m+[m[32m     if (binaryInputs[SWITCH_TILT_LEFT].getEdgeDown()){[m
[32m+[m[32m         this->dataPlayer.loadDataSet(0);[m
[32m+[m[32m         this->dataPlayer.setSetIndexDirection(1);[m
[32m+[m[32m     }[m
[32m+[m[32m     if (binaryInputs[SWITCH_TILT_RIGHT].getEdgeDown()){[m
[32m+[m[32m         this->dataPlayer.loadDataSet(0);[m
[32m+[m[32m         this->dataPlayer.setSetIndexDirection(0);[m
[32m+[m[32m     }[m
[32m+[m[32m     this->dataPlayer.update();[m
[32m+[m[32m     screen = this->dataPlayer.getActive32bit();[m
[32m+[m[41m [m
[32m+[m[32m     ledDisp->SetFourDigits(screen);[m[41m  [m
[32m+[m[41m [m
   }else{[m
[31m-		if (binaryInputs[SWITCH_TILT_FORWARD].getEdgeDown()){[m
[31m-			buzzer->programBuzzerRoll(1); //not beep but "puck"[m
[31m-			counter2|=0x01<<TILT_FORWARD;[m
[31m-		}[m
[31m-[m
[31m-		if (binaryInputs[SWITCH_TILT_BACKWARD].getEdgeDown()){[m
[31m-			buzzer->programBuzzerRoll(1); //not beep but "puck"[m
[31m-			counter2|=0x01<<TILT_BACKWARD;[m
[31m-		}[m
[31m-[m
[31m-		if (binaryInputs[SWITCH_TILT_LEFT].getEdgeDown()){[m
[31m-			buzzer->programBuzzerRoll(1); //not beep but "puck"[m
[31m-			counter2|=0x01<<TILT_LEFT;[m
[31m-		}[m
[31m-[m
[31m-		if (binaryInputs[SWITCH_TILT_RIGHT].getEdgeDown()){[m
[31m-			buzzer->programBuzzerRoll(1); //not beep but "puck"[m
[31m-			counter2|=0x01<<TILT_RIGHT;[m
[31m-		}[m
[31m-[m
[31m-		if(counter2>0 || counter > 0){  [m
[31m-	  [m
[31m-		  for (uint8_t i=0;i<=counter;i++){[m
[31m-			  [m
[31m-			  if (1<<TILT_FORWARD & counter2 || i<counter){[m
[31m-				screen |= (uint32_t)pgm_read_byte_near(tilt_forward + i)<< (8*i); //* 4 --> 4 bytes per dword[m
[31m-			  }[m
[31m-			  if (1<<TILT_BACKWARD & counter2 || i<counter){[m
[31m-				screen |= (uint32_t)pgm_read_byte_near(tilt_backward + i)<< (8*i); //* 4 --> 4 bytes per dword[m
[31m-			  }[m
[31m-			  if (1<<TILT_LEFT & counter2 || i<counter){[m
[31m-				screen |= (uint32_t)pgm_read_byte_near(tilt_left + i)<< (8*i); //* 4 --> 4 bytes per dword[m
[31m-			  }[m
[31m-			  if (1<<TILT_RIGHT & counter2 || i<counter){[m
[31m-				screen |= (uint32_t)pgm_read_byte_near(tilt_right + i)<< (8*i); //* 4 --> 4 bytes per dword[m
[31m-			  }[m
[31m-		  }	[m
[32m+[m[32m        if (binaryInputs[SWITCH_TILT_FORWARD].getEdgeDown()){[m
[32m+[m[32m            buzzer->programBuzzerRoll(1); //not beep but "puck"[m
[32m+[m[32m            counter2|=0x01<<TILT_FORWARD;[m
[32m+[m[32m        }[m
[32m+[m[41m [m
[32m+[m[32m        if (binaryInputs[SWITCH_TILT_BACKWARD].getEdgeDown()){[m
[32m+[m[32m            buzzer->programBuzzerRoll(1); //not beep but "puck"[m
[32m+[m[32m            counter2|=0x01<<TILT_BACKWARD;[m
[32m+[m[32m        }[m
[32m+[m[41m [m
[32m+[m[32m        if (binaryInputs[SWITCH_TILT_LEFT].getEdgeDown()){[m
[32m+[m[32m            buzzer->programBuzzerRoll(1); //not beep but "puck"[m
[32m+[m[32m            counter2|=0x01<<TILT_LEFT;[m
[32m+[m[32m        }[m
[32m+[m[41m [m
[32m+[m[32m        if (binaryInputs[SWITCH_TILT_RIGHT].getEdgeDown()){[m
[32m+[m[32m            buzzer->programBuzzerRoll(1); //not beep but "puck"[m
[32m+[m[32m            counter2|=0x01<<TILT_RIGHT;[m
[32m+[m[32m        }[m
[32m+[m[41m [m
[32m+[m[32m        if(counter2>0 || counter > 0){[m[41m  [m
[32m+[m[41m       [m
[32m+[m[32m          for (uint8_t i=0;i<=counter;i++){[m
[32m+[m[41m               [m
[32m+[m[32m              if (1<<TILT_FORWARD & counter2 || i<counter){[m
[32m+[m[32m                screen |= (uint32_t)pgm_read_byte_near(tilt_forward + i)<< (8*i); //* 4 --> 4 bytes per dword[m
[32m+[m[32m              }[m
[32m+[m[32m              if (1<<TILT_BACKWARD & counter2 || i<counter){[m
[32m+[m[32m                screen |= (uint32_t)pgm_read_byte_near(tilt_backward + i)<< (8*i); //* 4 --> 4 bytes per dword[m
[32m+[m[32m              }[m
[32m+[m[32m              if (1<<TILT_LEFT & counter2 || i<counter){[m
[32m+[m[32m                screen |= (uint32_t)pgm_read_byte_near(tilt_left + i)<< (8*i); //* 4 --> 4 bytes per dword[m
[32m+[m[32m              }[m
[32m+[m[32m              if (1<<TILT_RIGHT & counter2 || i<counter){[m
[32m+[m[32m                screen |= (uint32_t)pgm_read_byte_near(tilt_right + i)<< (8*i); //* 4 --> 4 bytes per dword[m
[32m+[m[32m              }[m
[32m+[m[32m          }[m[41m [m
       ledDisp->SetFourDigits(screen);  [m
[31m-  [m
[32m+[m[41m   [m
     }else{[m
       ledDisp->displayHandler(textBuf);[m
     }[m
   }[m
[31m-  [m
[32m+[m[41m   [m
   // keep track of progress[m
   if (counter2 == 0x0F){ //if a digit is complete[m
     counter++;[m
[36m@@ -1434,79 +1437,80 @@[m [mvoid Apps::tiltSwitchTest(bool init){[m
     counter2 = 0;[m
   }[m
 }[m
[31m-[m
[32m+[m[41m [m
 void Apps::modeGeiger(bool init){[m
[31m-[m
[32m+[m[41m [m
   if (init){[m
     //textBuf[4]=' ';[m
     COUNTER_GEIGER = 0;[m
[31m-	  GEIGER_TONE_FREQUENY_LOWEST = 2000;[m
[31m-	  GEIGER_TONE_FREQUENCY_HEIGHEST = 4000;[m
[31m-	  GEIGER_TONE_LENGTH = 10;[m
[32m+[m[32m      GEIGER_TONE_FREQUENY_LOWEST = 2000;[m
[32m+[m[32m      GEIGER_TONE_FREQUENCY_HEIGHEST = 4000;[m
[32m+[m[32m      GEIGER_TONE_LENGTH = 10;[m
   }[m
[31m-    [m
[32m+[m[41m     [m
   //play tick. [m
   //wait random time.[m
   //X = - log(1 - Y)/ K   with Y a random value ( 0<Y<1) and K a constant ?[m
   long r = random(0, 1024)*random(0, 1024); [m
   //long r = random(0, 1024);[m
   //r = r*r;[m
[31m-[m
[32m+[m[41m [m
   if (binaryInputs[BUTTON_LATCHING_BIG_RED].getValue()){[m
[31m-[m
[32m+[m[41m [m
     if (binaryInputs[BUTTON_MOMENTARY_0].getValue()){[m
       //lower[m
       if (potentio->getValueStableChangedEdge()){[m
         GEIGER_TONE_FREQUENY_LOWEST = potentio->getValueMapped(0,5000);[m
       }[m
       ledDisp->showNumber(GEIGER_TONE_FREQUENY_LOWEST);[m
[31m-[m
[32m+[m[41m [m
     }else if (binaryInputs[BUTTON_MOMENTARY_1].getValue()){[m
       //upper[m
       if (potentio->getValueStableChangedEdge()){[m
         GEIGER_TONE_FREQUENCY_HEIGHEST = potentio->getValueMapped(0,5000);[m
       }[m
       ledDisp->showNumber(GEIGER_TONE_FREQUENCY_HEIGHEST);[m
[31m-[m
[32m+[m[41m [m
     }else if (binaryInputs[BUTTON_MOMENTARY_2].getValue()){[m
       //length[m
       if (potentio->getValueStableChangedEdge()){[m
         GEIGER_TONE_LENGTH = potentio->getValueMapped(0,256);[m
       }[m
       ledDisp->showNumber(GEIGER_TONE_LENGTH);[m
[31m-[m
[31m-    } else if(binaryInputs[BUTTON_MOMENTARY_3].getValue()){[m
[32m+[m[41m [m
[32m+[m[32m#ifdef BUTTON_MOMENTARY_3[m
[32m+[m[32m    }else if(binaryInputs[BUTTON_MOMENTARY_3].getValue()){[m
       if (potentio->getValueStableChangedEdge()){[m
         buzzer->playTone([m
             potentio->getValueMapped(0,500), [m
             binaryInputs[BUTTON_LATCHING_EXTRA].getValue()?0:GEIGER_TONE_LENGTH[m
           );[m
       }[m
[31m-[m
[32m+[m[32m#endif[m
     }else{[m
[31m-[m
[32m+[m[41m [m
       if (r > GEIGER_PROBABILITY_THRESHOLD){ // 1024*1024[m
         long tmp  =  random(GEIGER_TONE_FREQUENY_LOWEST, GEIGER_TONE_FREQUENCY_HEIGHEST+1);[m
         buzzer->playTone([m
           tmp , [m
           binaryInputs[BUTTON_LATCHING_EXTRA].getValue()?0:GEIGER_TONE_LENGTH[m
           );[m
[31m-[m
[32m+[m[41m [m
         ledDisp->showNumber(tmp);[m
         COUNTER_GEIGER++;[m
       }[m
[31m-[m
[32m+[m[41m [m
       if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){[m
         ledDisp->showNumber(COUNTER_GEIGER);[m
       }[m
[31m-      [m
[32m+[m[41m       [m
       GEIGER_PROBABILITY_THRESHOLD = potentio->getValueMapped(0,1048576);[m
     }[m
[31m-    [m
[32m+[m[41m     [m
   }else{[m
     // simple Geiger mode[m
     // todo: idea: if tilted forward, dramatically increase chance, tilted backward, decrease. This way, we can truly simulate a geiger counte.r[m
[31m-    [m
[32m+[m[41m     [m
     // If you press the button and approach an object, the object appears super radio active! hi-la-ri-ous![m
     if ( binaryInputs[BUTTON_MOMENTARY_1].getValue()){[m
       // binaryInputs[SWITCH_TILT_FORWARD].getValue() ||[m
[36m@@ -1517,80 +1521,80 @@[m [mvoid Apps::modeGeiger(bool init){[m
         GEIGER_INCREASE_CHANCE-=1500;[m
       }[m
     }[m
[31m-[m
[32m+[m[41m [m
     r+=GEIGER_INCREASE_CHANCE;[m
[31m-[m
[31m-	  textBuf[1]=' '; [m
[32m+[m[41m [m
[32m+[m[32m      textBuf[1]=' ';[m[41m [m
     if (r > potentio->getValueMapped(0,1048576)){[m
       //    buzzer->programBuzzerRoll(1); //not beep but "puck"[m
       buzzer->playTone((unsigned int)50, 10);[m
       textBuf[1]='?';[m
[31m-    [m
[32m+[m[41m     [m
     }[m
[31m-[m
[32m+[m[41m [m
     //all digits same value[m
     for(uint8_t i=2;i<5;i++){[m
       textBuf[i]=textBuf[1];[m
     }[m
[31m-    [m
[32m+[m[41m     [m
     ledDisp->displayHandler(textBuf);  [m
   }[m
 }[m
[31m-[m
[32m+[m[41m [m
 void Apps::modeSequencer(bool init){[m
[31m-	int8_t step = 0;[m
[31m-[m
[32m+[m[32m    int8_t step = 0;[m
[32m+[m[41m [m
   if (!binaryInputs[BUTTON_LATCHING_BIG_RED].getValue()){ [m
     // metrone function is the "easy mode here"[m
     this->modeMetronome(init);[m
     return;[m
   }[m
[31m-    [m
[32m+[m[41m     [m
   if (init){[m
     SEQUENCER_STEP_COUNTER = 0; [m
     SEQUENCER_TEMPORARY_TRANSPOSE_OFFSET = 0;[m
     generalTimer.setInitTimeMillis((long)potentio->getValueStable() * -1);[m
     generalTimer.start();[m
[31m-[m
[32m+[m[41m [m
     SEQUENCER_EEPROM_MODE_BLINK.setInitTimeMillis(-1000);[m
     SEQUENCER_EEPROM_MODE_BLINK.start();[m
[31m-    [m
[32m+[m[41m     [m
     //resets song.[m
     for (uint8_t i=0;i<32;i++){[m
       this->SEQUENCER_SONG[i] = C7_8;[m
     }[m
   }[m
[31m-  [m
[32m+[m[41m   [m
   if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getEdgeDown()){[m
     init = true; // make sure we display the sequencer when returning from save/load mode[m
   }[m
[31m-[m
[32m+[m[41m [m
   if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){ [m
     // load/save songs to the sequencer[m
     //blink alternatively song number and "load" or "save"[m
     uint8_t song_number  = potentio->getValueMapped(1,9);[m
     if (TIMER_REACTION_GAME_RESTART_DELAY.getInFirstGivenHundredsPartOfSecond(500)){[m
       ledDisp->showNumber(song_number);[m
[31m-[m
[32m+[m[41m [m
     }else{[m
[31m-      [m
[32m+[m[41m       [m
       if(binaryInputs[BUTTON_LATCHING_EXTRA].getValue()){[m
         textBuf[1] = 'S';[m
         textBuf[2] = 'A';[m
         textBuf[3] = 'V';[m
         textBuf[4] = 'E';[m
[31m-      [m
[32m+[m[41m       [m
       }else{[m
         textBuf[1] = 'L';[m
         textBuf[2] = 'O';[m
         textBuf[3] = 'A';[m
         textBuf[4] = 'D';[m
[31m-[m
[32m+[m[41m [m
       }[m
[31m-[m
[32m+[m[41m [m
       ledDisp->displayHandler(textBuf);[m
     }[m
[31m-[m
[32m+[m[41m [m
     if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m
       for (uint8_t i=0;i<32;i++){[m
         uint8_t eeprom_address = (uint8_t*)[m
[36m@@ -1598,78 +1602,78 @@[m [mvoid Apps::modeSequencer(bool init){[m
                (song_number - 1) * EEPROM_SEQUENCER_SONG_LENGTH +[m
                i               [m
               );[m
[31m-[m
[32m+[m[41m [m
         if(binaryInputs[BUTTON_LATCHING_EXTRA].getValue()){[m
           //save[m
           eeprom_write_byte(eeprom_address, this->SEQUENCER_SONG[i]);[m
[31m-[m
[32m+[m[41m [m
         }else{[m
           //load[m
           this->SEQUENCER_SONG[i] = eeprom_read_byte(eeprom_address);[m
         }[m
       }[m
     }[m
[31m-[m
[32m+[m[41m [m
     if (binaryInputs[BUTTON_MOMENTARY_0].getValue()){[m
       TIMER_REACTION_GAME_RESTART_DELAY.start();[m
     }[m
[31m-    [m
[31m-[m
[32m+[m[41m     [m
[32m+[m[41m [m
   }else{[m
     // manipulate the sequencer[m
[31m-[m
[31m-[m
[32m+[m[41m [m
[32m+[m[41m [m
     // visualize programmed note[m
[31m-[m
[32m+[m[41m [m
     SEQUENCER_TEMP_NOTE = SEQUENCER_SONG[SEQUENCER_STEP_COUNTER];[m
[31m-[m
[32m+[m[41m [m
     if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m
       buzzer->programBuzzerRoll(SEQUENCER_TEMP_NOTE);[m
       ledDisp->showNumber(SEQUENCER_TEMP_NOTE);[m
     }[m
[31m-[m
[32m+[m[41m [m
     if (binaryInputs[BUTTON_MOMENTARY_0].getValue()){[m
       // if button continuously pressed, show notes.[m
       ledDisp->showNumber(SEQUENCER_TEMP_NOTE);[m
[31m-[m
[32m+[m[41m [m
       // bonus effect: TRANSPOSE![m
       if (potentio->getValueStableChangedEdge()){[m
         SEQUENCER_TEMPORARY_TRANSPOSE_OFFSET += 2 * potentio->getLastStableValueChangedUp() - 1; //step +1 or -1[m
       }[m
     } [m
[31m-    [m
[32m+[m[41m     [m
     if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeDown()){[m
       ledDisp->SetFourDigits(displayAllSegments);[m
     }[m
[31m-[m
[32m+[m[41m [m
     // just listen to the potentio note[m
     SEQUENCER_TEMP_NOTE = potentio->getValueMapped(0,255);  [m
[31m-[m
[32m+[m[41m [m
     if (binaryInputs[BUTTON_MOMENTARY_1].getEdgeUp()){[m
       buzzer->programBuzzerRoll(SEQUENCER_TEMP_NOTE);[m
       ledDisp->showNumber(SEQUENCER_TEMP_NOTE);[m
     }[m
[31m-    [m
[32m+[m[41m     [m
     if (binaryInputs[BUTTON_MOMENTARY_1].getValue()){[m
       // if button continuously pressed, rotate potentio to hear notes.[m
       if (potentio->getValueStableChangedEdge()){[m
[31m-        [m
[32m+[m[41m         [m
         buzzer->programBuzzerRoll(SEQUENCER_TEMP_NOTE);[m
         ledDisp->showNumber(SEQUENCER_TEMP_NOTE);[m
       }[m
     } [m
[31m-    [m
[32m+[m[41m     [m
     if (binaryInputs[BUTTON_MOMENTARY_1].getEdgeDown()){[m
       ledDisp->SetFourDigits(displayAllSegments);[m
     }[m
[31m-[m
[32m+[m[41m [m
     // program note to song[m
     if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
[31m-      [m
[32m+[m[41m       [m
       uint8_t note = potentio->getValueMapped(0,255);[m
[31m-      [m
[32m+[m[41m       [m
       buzzer->programBuzzerRoll(note);[m
[31m-[m
[32m+[m[41m [m
       if (binaryInputs[BUTTON_LATCHING_SMALL_RED_RIGHT].getValue()){ [m
         //copy to all measures[m
         for (uint8_t i=0;i<4;i++){[m
[36m@@ -1679,55 +1683,59 @@[m [mvoid Apps::modeSequencer(bool init){[m
         this->SEQUENCER_SONG[SEQUENCER_STEP_COUNTER] = note;[m
       }[m
     }[m
[31m-    [m
[32m+[m[41m     [m
[32m+[m[32m#ifdef BUTTON_MOMENTARY_3[m
     // song progression[m
     if (binaryInputs[BUTTON_MOMENTARY_3].getEdgeUp()){[m
       step = 1;[m
     }[m
[31m-    [m
[32m+[m[41m [m
     if (binaryInputs[BUTTON_MOMENTARY_3].getValue()){[m
       if (potentio->getValueStableChangedEdge()){[m
         step = 2 * potentio->getLastStableValueChangedUp() - 1; //step +1 or -1[m
       }[m
     }[m
[31m-[m
[32m+[m[32m#endif[m
[32m+[m[41m [m
     // autoplay[m
     if (binaryInputs[BUTTON_LATCHING_EXTRA].getValue()){[m
       // change speed is default behaviour of potentio.[m
         if (!binaryInputs[BUTTON_MOMENTARY_0].getValue() && [m
             !binaryInputs[BUTTON_MOMENTARY_1].getValue() &&[m
             !binaryInputs[BUTTON_MOMENTARY_2].getValue() &&[m
[32m+[m[32m#ifdef BUTTON_MOMENTARY_3[m
             !binaryInputs[BUTTON_MOMENTARY_3].getValue() &&[m
[32m+[m[32m#endif[m
             potentio->getValueStableChangedEdge()){[m
[31m-[m
[32m+[m[41m [m
             //  generalTimer.setInitTimeMillis(potentio->getValueMapped(-1024,0));[m
             int8_t tmp = 2 * potentio->getLastStableValueChangedUp() - 1;[m
             generalTimer.setInitTimeMillis(generalTimer.getInitTimeMillis() + tmp * 10) ; //step +1 or -1[m
       }[m
[31m-[m
[32m+[m[41m [m
       if (!generalTimer.getTimeIsNegative()){[m
         step = 1;[m
         generalTimer.start();[m
       }[m
     }[m
[31m-    [m
[32m+[m[41m     [m
     // handle step change[m
     if (step != 0 || init){[m
       SEQUENCER_STEP_COUNTER+=step;[m
[31m-[m
[32m+[m[41m [m
       if (SEQUENCER_STEP_COUNTER < 0){[m
         SEQUENCER_STEP_COUNTER = 31;[m
       }[m
[31m-[m
[32m+[m[41m [m
       if (SEQUENCER_STEP_COUNTER > 31){[m
         SEQUENCER_STEP_COUNTER = 0;[m
       }[m
[31m-      [m
[32m+[m[41m       [m
       buzzer->programBuzzerRoll([m
         this->SEQUENCER_SONG[SEQUENCER_STEP_COUNTER] + [m
         SEQUENCER_TEMPORARY_TRANSPOSE_OFFSET * binaryInputs[BUTTON_MOMENTARY_0].getValue()[m
         );[m
[31m-      [m
[32m+[m[41m       [m
       // sequencer shows every step in 32 notes bar. 8steps (circle) times 4 measures (bar on bottom)[m
       displayAllSegments = 0;[m
       if (SEQUENCER_STEP_COUNTER % 8 < 4){[m
[36m@@ -1735,19 +1743,19 @@[m [mvoid Apps::modeSequencer(bool init){[m
       }else{[m
         displayAllSegments |=  (uint32_t)0x1 << ((8*( 3 - ( SEQUENCER_STEP_COUNTER % 8 -4 ))) + 6); [m
       }[m
[31m-      [m
[32m+[m[41m       [m
       displayAllSegments |=  (uint32_t)0x1 << ((8*(SEQUENCER_STEP_COUNTER / 8))+3) ;  // bar at bottom.[m
       ledDisp->SetFourDigits(displayAllSegments);[m
[31m-[m
[32m+[m[41m [m
     }[m
   }[m
 }[m
[31m-[m
[32m+[m[41m [m
 void Apps::modeMetronome(bool init){[m
   // todo: with extra timer, create slight timing offset in second ticker, for fun effects (zwevingen)![m
   bool update = false;[m
   bool nextStep = false;[m
[31m-  [m
[32m+[m[41m   [m
   if (init){[m
     METRONOME_TICKER_1_POSITION = 0;[m
     METRONOME_TICKER_2_POSITION = 0;[m
[36m@@ -1756,30 +1764,30 @@[m [mvoid Apps::modeMetronome(bool init){[m
     TIMER_METRONOME.start();[m
     update = true;[m
   }[m
[31m-  [m
[32m+[m[41m   [m
   if (binaryInputs[BUTTON_LATCHING_EXTRA].getValue()){[m
[31m-[m
[32m+[m[41m [m
     if (potentio->getValueStableChangedEdge()){[m
       TIMER_METRONOME.setInitTimeMillis(potentio->getValueMapped(-1024,0));[m
     }[m
[31m-    [m
[32m+[m[41m     [m
     if (!TIMER_METRONOME.getTimeIsNegative()){[m
[31m-      [m
[32m+[m[41m       [m
       TIMER_METRONOME.start();[m
       update = true;[m
       nextStep = true;[m
     }[m
   }[m
[31m-  [m
[32m+[m[41m   [m
   if (binaryInputs[BUTTON_MOMENTARY_0].getEdgeUp()){[m
     //ticker 1,2 and 3 back together (at position of ticker 1)[m
     METRONOME_TICKER_2_POSITION = METRONOME_TICKER_1_POSITION;[m
     METRONOME_TICKER_3_POSITION = METRONOME_TICKER_1_POSITION;[m
     update = true;[m
   }[m
[31m-[m
[32m+[m[41m [m
   if (binaryInputs[BUTTON_MOMENTARY_1].getEdgeUp()){[m
[31m-  [m
[32m+[m[41m   [m
     //set ticker 2 one step extra forward .[m
     METRONOME_TICKER_2_POSITION = this->nextStepRotate([m
       METRONOME_TICKER_2_POSITION, [m
[36m@@ -1789,8 +1797,8 @@[m [mvoid Apps::modeMetronome(bool init){[m
       11);[m
     update = true;[m
   }[m
[31m-  [m
[31m-[m
[32m+[m[41m   [m
[32m+[m[41m [m
   if (binaryInputs[BUTTON_MOMENTARY_2].getEdgeUp()){[m
     //set ticker 3 one step extra forward .[m
     METRONOME_TICKER_3_POSITION = this->nextStepRotate([m
[36m@@ -1801,22 +1809,24 @@[m [mvoid Apps::modeMetronome(bool init){[m
       11);[m
     update = true;[m
   }[m
[31m-[m
[32m+[m[41m [m
[32m+[m[32m#ifdef BUTTON_MOMENTARY_3[m
   if (binaryInputs[BUTTON_MOMENTARY_3].getEdgeUp()){[m
     update = true;[m
     nextStep = true;[m
   }[m
[31m-[m
[32m+[m[32m#endif[m
[32m+[m[41m [m
   if (update){[m
[31m-    [m
[31m-[m
[32m+[m[41m     [m
[32m+[m[41m [m
     if (nextStep){[m
       METRONOME_TICKER_1_POSITION = this->nextStepRotate([m
         METRONOME_TICKER_1_POSITION, [m
         true,[m
         0, [m
         11);[m
[31m-[m
[32m+[m[41m [m
       METRONOME_TICKER_2_POSITION = this->nextStepRotate([m
         METRONOME_TICKER_2_POSITION, [m
         !binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue(), [m
[36m@@ -1830,21 +1840,21 @@[m [mvoid Apps::modeMetronome(bool init){[m
         0, [m
         11);[m
     }  [m
[31m-[m
[32m+[m[41m [m
     if (METRONOME_TICKER_1_POSITION == 0){[m
       buzzer->programBuzzerRoll(C7_8);[m
     }[m
[31m-[m
[32m+[m[41m [m
     if (METRONOME_TICKER_2_POSITION == 0){[m
       buzzer->programBuzzerRoll(C6_4);[m
     }[m
[31m-[m
[32m+[m[41m [m
     if ( (METRONOME_TICKER_3_POSITION == 0) && [m
       (METRONOME_TICKER_3_POSITION != METRONOME_TICKER_1_POSITION)[m
       ){[m
       buzzer->programBuzzerRoll(C5_4);[m
     }[m
[31m-[m
[32m+[m[41m [m
     uint32_t screen = 0;[m
     for (uint8_t i=0;i<4;i++){[m
       screen |= (uint32_t)pgm_read_byte_near(disp_4digits_animate_circle + METRONOME_TICKER_1_POSITION*4 + (i)) << (8*i); //* 4 --> 4 bytes per dword[m
[36m@@ -1852,30 +1862,30 @@[m [mvoid Apps::modeMetronome(bool init){[m
       screen |= (uint32_t)pgm_read_byte_near(disp_4digits_animate_circle + METRONOME_TICKER_3_POSITION*4 + (i)) << (8*i); [m
     }[m
     ledDisp->SetFourDigits(screen);[m
[31m-[m
[32m+[m[41m [m
   }  [m
 }[m
[31m-[m
[32m+[m[41m [m
 #ifdef SIMON_APP[m
[31m-[m
[32m+[m[41m [m
 void Apps::modeSimon(bool init)[m
 {[m
   const int numButtons = 4;[m
   const int buttons[numButtons] = { BUTTON_LATCHING_EXTRA, BUTTON_MOMENTARY_0, BUTTON_MOMENTARY_1, BUTTON_MOMENTARY_2 };[m
   const byte lights[numButtons] = { 1 << LIGHT_YELLOW, 1 << LIGHT_RED, 1 << LIGHT_GREEN, 1 << LIGHT_BLUE };[m
   const uint8_t sounds[numButtons] = { C4_1, F4_1, A4_1, C5_1};[m
[31m-[m
[32m+[m[41m [m
   const bool hasSound = binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue();[m
   const bool hasLight = binaryInputs[BUTTON_LATCHING_SMALL_RED_RIGHT].getValue() || !hasSound;[m
[31m-[m
[32m+[m[41m [m
   if (init) {[m
     simonState = simonWaitForNewGame;[m
   }[m
[31m-[m
[32m+[m[41m [m
   if (init || potentio->getValueStableChangedEdge()) {[m
     generalTimer.setInitTimeMillis(potentio->getValueMapped(-1000,-100));[m
   }[m
[31m-[m
[32m+[m[41m [m
   uint8_t buttonsChanged = 0;[m
   for (int k = 0; k < numButtons; ++k) {[m
     const bool changed = (buttons[k] == BUTTON_LATCHING_EXTRA)[m
[36m@@ -1885,7 +1895,7 @@[m [mvoid Apps::modeSimon(bool init)[m
       buttonsChanged |= (1 << k);[m
     }[m
   }[m
[31m-[m
[32m+[m[41m [m
   switch (simonState) {[m
     case simonWaitForNewGame: {[m
       // all lights on[m
[36m@@ -1900,7 +1910,7 @@[m [mvoid Apps::modeSimon(bool init)[m
       simonState = simonNewGame;[m
       break;[m
     }[m
[31m-[m
[32m+[m[41m [m
     case simonNewGame: {[m
       ledDisp->SetLedArray(0);[m
       // generate new sequence[m
[36m@@ -1913,7 +1923,7 @@[m [mvoid Apps::modeSimon(bool init)[m
       simonState = simonNewLevel;[m
       break;[m
     }[m
[31m-[m
[32m+[m[41m [m
     case simonNewLevel: {[m
       ledDisp->showNumber(SIMON_LENGTH);[m
       ++SIMON_LENGTH;[m
[36m@@ -1928,7 +1938,7 @@[m [mvoid Apps::modeSimon(bool init)[m
       generalTimer.start();[m
       break;[m
     }[m
[31m-[m
[32m+[m[41m [m
     case simonPlaySequence: {[m
       if (generalTimer.getTimeIsNegative()) {[m
         break;[m
[36m@@ -1952,7 +1962,7 @@[m [mvoid Apps::modeSimon(bool init)[m
       ++SIMON_INDEX;[m
       break;[m
     }[m
[31m-[m
[32m+[m[41m [m
     case simonUserRepeats: {[m
       if (!buttonsChanged) {[m
         break;[m
[36m@@ -1977,15 +1987,15 @@[m [mvoid Apps::modeSimon(bool init)[m
   }[m
 }[m
 #endif [m
[31m-[m
[32m+[m[41m [m
 int16_t Apps::nextStepRotate(int16_t counter, bool countUpElseDown, int16_t minValue, int16_t maxValue){[m
[31m-[m
[32m+[m[41m [m
      if (countUpElseDown){[m
         counter++;[m
      }else{[m
         counter--;[m
      }[m
[31m-[m
[32m+[m[41m [m
      if (counter > maxValue){[m
         counter = minValue;[m
      }[m
[36m@@ -1994,50 +2004,50 @@[m [mint16_t Apps::nextStepRotate(int16_t counter, bool countUpElseDown, int16_t minV[m
      }[m
      return counter;[m
 }[m
[31m-[m
[31m-[m
[32m+[m[41m [m
[32m+[m[41m [m
 void Apps::modeReactionGame(bool init){[m
   #ifdef ENABLE_REACTION_APP[m
   //yellow button active at start: yellow button is also a guess button[m
   // big red active: timed game[m
   // small red right active: time progressively shorter as game advances[m
   // small red left active: play by sound.[m
[31m-  [m
[32m+[m[41m   [m
   if (init){[m
     randomSeed(millis());[m
     reactionGameState = reactionWaitForStart;[m
     displayAllSegments = 0x0;[m
     TIMER_REACTION_GAME_RESTART_DELAY.setInitTimeMillis(0);[m
[31m-        [m
[32m+[m[41m         [m
     TIMER_REACTION_GAME_RESTART_DELAY.start();[m
[31m-[m
[32m+[m[41m [m
   }[m
[31m-[m
[32m+[m[41m [m
   // at any time, leave game when depressing play button.[m
   if (binaryInputs[BUTTON_LATCHING_EXTRA].getEdgeDown() ){[m
     reactionGameState = reactionWaitForStart;[m
   }[m
[31m- [m
[32m+[m[41m  [m
   switch (reactionGameState) {[m
[31m-[m
[32m+[m[41m [m
     case reactionWaitForStart: {[m
[31m-[m
[32m+[m[41m [m
       // change level[m
       REACTION_GAME_LEVEL = (potentio->getValueMapped(1,5)); // only set the default inittime at selecting the game. If multiple games are played, init time stays the same.[m
       if (potentio->getValueStableChangedEdge()){[m
         TIMER_REACTION_GAME_RESTART_DELAY.start();[m
       }[m
[31m-[m
[32m+[m[41m [m
       // special mode for the reaction game: limited total time during which as many points should be collected. [m
       REACTION_COUNTDOWN_MODE = binaryInputs[BUTTON_LATCHING_SMALL_RED_RIGHT].getValue();[m
       REACTION_GUITAR_HERO_MODE = binaryInputs[BUTTON_LATCHING_BIG_RED].getValue();[m
[31m-[m
[32m+[m[41m [m
       // guitar hero and countdown mode should never occure at the same time![m
       if (REACTION_GUITAR_HERO_MODE && REACTION_COUNTDOWN_MODE){[m
         // error!!![m
         REACTION_COUNTDOWN_MODE = false; // no reaction count downmode for guitar hero.[m
       }[m
[31m-[m
[32m+[m[41m [m
       // display level and high score[m
       #ifdef ENABLE_EEPROM[m
       if (TIMER_REACTION_GAME_RESTART_DELAY.getInFirstGivenHundredsPartOfSecond(500)){[m
[36m@@ -2046,8 +2056,8 @@[m [mvoid Apps::modeReactionGame(bool init){[m
         ledDisp->displayHandler(textBuf);[m
       }else{[m
         //ledDisp->setBlankDisplay(); //make high score blink[m
[31m-        [m
[31m-[m
[32m+[m[41m         [m
[32m+[m[41m [m
         ledDisp->showNumber([m
           eeprom_read_word([m
               (uint16_t*)[m
[36m@@ -2064,19 +2074,19 @@[m [mvoid Apps::modeReactionGame(bool init){[m
       textBuf[1] = 'L';[m
       ledDisp->displayHandler(textBuf);[m
       #endif[m
[31m-[m
[31m-        [m
[32m+[m[41m [m
[32m+[m[41m         [m
       // play game button pressed[m
       if (binaryInputs[BUTTON_LATCHING_EXTRA].getEdgeUp() ){[m
         reactionGameState = reactionNewGame;[m
[31m-[m
[32m+[m[41m [m
         if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){[m
           //play by sound[m
           for (uint8_t i=0;i<MOMENTARY_BUTTONS_COUNT;i++){[m
[31m-            [m
[32m+[m[41m             [m
             REACTION_GAME_SELECTED_SOUNDS[i] = (uint8_t)random(234, 245);[m
[31m-            [m
[31m-            [m
[32m+[m[41m             [m
[32m+[m[41m             [m
             for (uint8_t j=0;j<i;j++){[m
               // never twice the same sound[m
               if (REACTION_GAME_SELECTED_SOUNDS[j] == REACTION_GAME_SELECTED_SOUNDS[i]){[m
[36m@@ -2086,21 +2096,21 @@[m [mvoid Apps::modeReactionGame(bool init){[m
           }[m
         }[m
       } [m
[31m-[m
[32m+[m[41m [m
       break;[m
     }[m
[31m-[m
[32m+[m[41m [m
     case reactionNewGame: {[m
[31m-      [m
[32m+[m[41m       [m
       REACTION_GAME_SCORE = 0;[m
[31m-[m
[32m+[m[41m [m
       if (binaryInputs[BUTTON_LATCHING_BIG_RED].getValue()){[m
[31m-[m
[32m+[m[41m [m
         reactionGameState = reactionMultiNewTurn;[m
         displayAllSegments = 0;[m
[31m-[m
[32m+[m[41m [m
         REACTION_GAME_STEP_TIME_MILLIS = (6-REACTION_GAME_LEVEL) * -200;[m
[31m-        [m
[32m+[m[41m         [m
       }else{[m
         if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){[m
           // let them all play so the player gets a feel for them.[m
[36m@@ -2108,58 +2118,58 @@[m [mvoid Apps::modeReactionGame(bool init){[m
             buzzer->programBuzzerRoll(REACTION_GAME_SELECTED_SOUNDS[i]);[m
             buzzer->programBuzzerRoll(rest_1);[m
           }[m
[31m-[m
[32m+[m[41m [m
           buzzer->programBuzzerRoll(rest_1);[m
           buzzer->programBuzzerRoll(rest_1);[m
         }  [m
[31m-[m
[32m+[m[41m [m
         reactionGameState = reactionNewTurn;[m
[31m-[m
[32m+[m[41m [m
         if (REACTION_COUNTDOWN_MODE){[m
           // if enabled, we go for "as many points in a limited time. --> this to make it more exciting for adults (can be boring after a while if you just have to press the right button in time)[m
           REACTION_GAME_STEP_TIME_MILLIS = (1UL << (REACTION_GAME_LEVEL )) * -4000; // step speed depending on level[m
[31m-[m
[32m+[m[41m [m
         }else{[m
           REACTION_GAME_STEP_TIME_MILLIS = (1UL << (6 - REACTION_GAME_LEVEL)) * -35; // step speed depending on level[m
         }[m
[31m-[m
[32m+[m[41m [m
       }[m
[31m-[m
[32m+[m[41m [m
       TIMER_REACTION_GAME_SPEED.setInitTimeMillis(REACTION_GAME_STEP_TIME_MILLIS);[m
       TIMER_REACTION_GAME_SPEED.start(); [m
       break;[m
[31m-[m
[32m+[m[41m [m
     }[m
[31m-[m
[32m+[m[41m [m
     case reactionMultiNewTurn: {[m
       // like in guitar hero, the horizontal segments in the screen fall down and button combo's have to be pressed to "catch" the falling segments.[m
[31m-      [m
[32m+[m[41m       [m
       // three rows of four horizontal segments in 4 digits 7 segment display. [m
       // choose top row random. any combination of 4 (including zero) ==> 16 combinations.[m
[31m-[m
[32m+[m[41m [m
       ledDisp->setBlankDisplay(); [m
       lights = 0b00000000;[m
[31m-     [m
[32m+[m[41m      [m
       uint8_t new_segment;[m
       uint32_t tmp_segments;[m
[31m-      [m
[32m+[m[41m       [m
       tmp_segments = 0;[m
[31m-      [m
[32m+[m[41m       [m
       // treat every segment separatly[m
       for (uint8_t i=0;i<MOMENTARY_BUTTONS_COUNT;i++){[m
         new_segment = 0;[m
         // get relevant segment[m
[31m-        [m
[31m-[m
[32m+[m[41m         [m
[32m+[m[41m [m
         //mid seg to bottom seg[m
         new_segment |= ((displayAllSegments >> (8*i)) & 0b01000000) >> 3;// G segment, move to D segment  0G00D000[m
[31m-        [m
[32m+[m[41m         [m
         //mid seg to DP seg[m
         new_segment |= ((displayAllSegments >> (8*i)) & 0b01000000) << 1;// G segment, move to DP segment  DP.G.0.0.0.0.0.0[m
[31m-[m
[32m+[m[41m [m
         //top seg to mid seg[m
         new_segment |= ((displayAllSegments >> (8*i)) & 0b00000001) << 6;// A segment, ON or OFF?, move to G segment[m
[31m-[m
[32m+[m[41m [m
         // random top[m
         // if (random(0, 2)){  // 0 or 1  // move to segment A)[m
         //   new_segment |= 1;[m
[36m@@ -2167,35 +2177,35 @@[m [mvoid Apps::modeReactionGame(bool init){[m
         //   new_segment &= ~(0b00000001);[m
         // }[m
         // new_segment |= random(0, 2);[m
[31m-        [m
[32m+[m[41m         [m
         if (random(0, 100) > 50){[m
           new_segment |= 0b00000001;[m
         }[m
[31m-[m
[32m+[m[41m [m
         tmp_segments |= ((uint32_t)new_segment) << (8*i);[m
[31m-        [m
[32m+[m[41m         [m
       }[m
[31m-[m
[32m+[m[41m [m
       displayAllSegments = tmp_segments;[m
[31m-[m
[32m+[m[41m [m
       //ledDisp->SetLedArray(lights); [m
       ledDisp->SetFourDigits(displayAllSegments);[m
       TIMER_REACTION_GAME_SPEED.start();[m
[31m-[m
[32m+[m[41m [m
       reactionGameState = reactionMultiPlaying;[m
       break; [m
     }[m
[31m-[m
[31m-[m
[31m-[m
[32m+[m[41m [m
[32m+[m[41m [m
[32m+[m[41m [m
     case reactionMultiPlaying: {[m
[31m-[m
[32m+[m[41m [m
       for (uint8_t i=0;i<MOMENTARY_BUTTONS_COUNT;i++){[m
[31m-[m
[32m+[m[41m [m
         if (binaryInputs[buttons_momentary_indexed[i]].getEdgeUp()){[m
           //if DP of this button was on, switch it off. else, die![m
           //check if DP of digit "i" is set[m
[31m-          [m
[32m+[m[41m           [m
           if (displayAllSegments & (0x80UL << 8*i)){[m
             // DP is on, set to zero.[m
             buzzer->addRandomSoundToRoll(190,198);[m
[36m@@ -2203,22 +2213,22 @@[m [mvoid Apps::modeReactionGame(bool init){[m
             REACTION_GAME_SCORE++; [m
             //buzzer->programBuzzerRoll(rest_1);[m
             //buzzer->programBuzzerRoll(C5_1);[m
[31m-            [m
[32m+[m[41m             [m
           }else{[m
              //DP is off --> button should not have been pressed --> die![m
             reactionGameState = reactionJustDied;[m
           }[m
         }[m
       }[m
[31m-[m
[32m+[m[41m [m
       if (!TIMER_REACTION_GAME_SPEED.getTimeIsNegative()){[m
       //   // if not all needed buttons pressed, player is dead.[m
       //   // check dps![m
[31m-        [m
[32m+[m[41m         [m
         if ((displayAllSegments & 0x80808080UL) != 0 ){[m
           // no success... (not all DP's cleared.)[m
           reactionGameState = reactionJustDied;[m
[31m-          [m
[32m+[m[41m           [m
         }else{[m
           // success![m
           reactionGameState = reactionMultiNewTurn;[m
[36m@@ -2228,53 +2238,53 @@[m [mvoid Apps::modeReactionGame(bool init){[m
       ledDisp->SetFourDigits(displayAllSegments);[m
       break;[m
     }[m
[31m-[m
[32m+[m[41m [m
     case reactionNewTurn:{[m
[31m-     [m
[32m+[m[41m      [m
       if (!REACTION_COUNTDOWN_MODE){[m
[31m-       [m
[32m+[m[41m        [m
         REACTION_GAME_TIMER_STEP= 0; //reset animation step[m
         TIMER_REACTION_GAME_SPEED.start(); // only restart if 12 steps time per turn[m
       }[m
       ledDisp->setBlankDisplay(); // yes, this is needed.[m
       displayAllSegments = 0; //reset animation graphics screen[m
[31m-      [m
[32m+[m[41m       [m
       lights = 0b00000000; //reset before switch enquiry[m
[31m-      [m
[32m+[m[41m       [m
       REACTION_GAME_TARGET = random(0, MOMENTARY_BUTTONS_COUNT);[m
[31m-      [m
[31m-      [m
[31m-      [m
[31m-[m
[32m+[m[41m       [m
[32m+[m[41m       [m
[32m+[m[41m       [m
[32m+[m[41m [m
       if (binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue()){[m
[31m-        [m
[32m+[m[41m         [m
         //play by sounds[m
         for (uint8_t j=0; j<4;j++){[m
           buzzer->programBuzzerRoll(rest_1);[m
[31m-[m
[32m+[m[41m [m
         }[m
         buzzer->programBuzzerRoll(REACTION_GAME_SELECTED_SOUNDS[REACTION_GAME_TARGET]);[m
[31m-[m
[32m+[m[41m [m
       }else{[m
         lights |= 1<<lights_indexed[REACTION_GAME_TARGET];     [m
       }[m
[31m-[m
[32m+[m[41m [m
       ledDisp->SetLedArray(lights); [m
[31m-[m
[32m+[m[41m [m
[32m+[m[41m            [m
[32m+[m[41m [m
            [m
[31m-[m
[31m-          [m
[31m-    [m
[32m+[m[41m     [m
       reactionGameState = reactionPlaying;[m
       break;[m
     }[m
[31m-[m
[31m-[m
[31m-[m
[31m-[m
[32m+[m[41m [m
[32m+[m[41m [m
[32m+[m[41m [m
[32m+[m[41m [m
     case reactionPlaying: {[m
[31m-      [m
[31m-      [m
[32m+[m[41m       [m
[32m+[m[41m       [m
       if (REACTION_COUNTDOWN_MODE){[m
         // if timer out, always dead.[m
         if (!TIMER_REACTION_GAME_SPEED.getTimeIsNegative()){[m
[36m@@ -2289,64 +2299,64 @@[m [mvoid Apps::modeReactionGame(bool init){[m
           }[m
         }[m
         ledDisp->SetFourDigits(displayAllSegments);[m
[31m-[m
[32m+[m[41m [m
       }else{[m
         // animation next step[m
[31m-      [m
[32m+[m[41m       [m
         if (!TIMER_REACTION_GAME_SPEED.getTimeIsNegative()){[m
           // game timing animation update.[m
           for (uint8_t i=0;i<4;i++){[m
             displayAllSegments |= (uint32_t)pgm_read_byte_near(disp_4digits_animate_circle + REACTION_GAME_TIMER_STEP*4 + (i)) << (8*i); [m
           }[m
           ledDisp->SetFourDigits(displayAllSegments);[m
[31m-          [m
[32m+[m[41m           [m
           REACTION_GAME_TIMER_STEP = this->nextStepRotate(REACTION_GAME_TIMER_STEP, true, 0, 12);[m
[31m-          [m
[32m+[m[41m           [m
           // check game status 'dead'[m
           if (REACTION_GAME_TIMER_STEP == 12){[m
             REACTION_GAME_TIMER_STEP = 0;[m
             displayAllSegments=0;    [m
[31m-            [m
[32m+[m[41m             [m
             reactionGameState = reactionJustDied;[m
[31m-          [m
[32m+[m[41m           [m
           }else{[m
             TIMER_REACTION_GAME_SPEED.start();[m
           }   [m
         }[m
       }[m
[31m-[m
[32m+[m[41m [m
       // set decimal point as "button lights" helper, in bright daylight button lights might not be visible.[m
[31m-[m
[32m+[m[41m [m
       if ( !binaryInputs[BUTTON_LATCHING_SMALL_RED_LEFT].getValue() ){[m
         //always show unless in soundmode[m
         ledDisp->setDecimalPoint(true, REACTION_GAME_TARGET+1);[m
       }[m
[31m-[m
[32m+[m[41m [m
       // check player pressed a button. [m
       for (uint8_t i=0;i<MOMENTARY_BUTTONS_COUNT;i++){[m
[31m-[m
[32m+[m[41m [m
         // button press[m
         if (binaryInputs[buttons_momentary_indexed[i]].getEdgeUp()){[m
[31m-          [m
[32m+[m[41m           [m
           if (i==REACTION_GAME_TARGET){[m
             //right button[m
             REACTION_GAME_SCORE++;[m
             reactionGameState = reactionNewTurn;[m
[31m-[m
[32m+[m[41m [m
           }else{[m
             //wrong button[m
             reactionGameState = reactionJustDied;[m
           }[m
         }[m
       }[m
[31m-[m
[32m+[m[41m [m
       break;[m
     }[m
[31m-    [m
[32m+[m[41m     [m
     case reactionJustDied:{[m
[31m-      [m
[32m+[m[41m       [m
       #ifdef ENABLE_EEPROM[m
[31m-[m
[32m+[m[41m [m
       //start high score end timer[m
       if (REACTION_GAME_SCORE > (int16_t)[m
             eeprom_read_word([m
[36m@@ -2368,35 +2378,35 @@[m [mvoid Apps::modeReactionGame(bool init){[m
           ),[m
           REACTION_GAME_SCORE[m
         );[m
[31m-[m
[32m+[m[41m [m
         buzzer->loadBuzzerTrack(song_attack );[m
       }[m
       #endif[m
[31m-[m
[32m+[m[41m [m
       TIMER_REACTION_GAME_RESTART_DELAY.setInitTimeMillis(-2000);[m
       TIMER_REACTION_GAME_RESTART_DELAY.start();[m
[31m-        [m
[32m+[m[41m         [m
       // play death song[m
       buzzer->programBuzzerRoll(F4_1);  [m
       buzzer->programBuzzerRoll(F4_1);  [m
       buzzer->programBuzzerRoll(F4_1);  [m
[31m-[m
[32m+[m[41m [m
       reactionGameState = reactionFinished;[m
[31m-[m
[32m+[m[41m [m
       break;[m
     }[m
[31m-    [m
[32m+[m[41m     [m
     case reactionFinished: {[m
       if (!TIMER_REACTION_GAME_RESTART_DELAY.getTimeIsNegative()){[m
         //end of display high score, next game[m
         reactionGameState = reactionNewGame;[m
[31m-          [m
[32m+[m[41m           [m
       }else {[m
[31m-[m
[32m+[m[41m [m
         //do nothing.  wait for display high score is finished.[m
         if (TIMER_REACTION_GAME_RESTART_DELAY.getInFirstGivenHundredsPartOfSecond(500)){[m
             ledDisp->setBlankDisplay(); //make high score blink[m
[31m-            [m
[32m+[m[41m             [m
         }else{[m
             ledDisp->showNumber(REACTION_GAME_SCORE); //score display. Leave at beginning, to display high score blinking.[m
             // intToDigitsString(textBuf+1, REACTION_GAME_SCORE, false);  // utilities lode[m
[36m@@ -2408,38 +2418,38 @@[m [mvoid Apps::modeReactionGame(bool init){[m
   }[m
   #endif[m
 }[m
[31m-[m
[32m+[m[41m [m
 uint32_t Apps::fadeInList(uint8_t step, uint8_t length, uint32_t startScreen, uint8_t* shuffledSequence ){[m
[31m-	[m
[31m-[m
[32m+[m[41m     [m
[32m+[m[41m [m
   // uint8_t sequence[32];[m
[31m-	// for (uint8_t i = 0; i < 32; i++) {[m
[31m-	// 	sequence[i] = i;[m
[31m-	// }[m
[31m-	[m
[31m-	// // shuffle in place[m
[31m-	// this->shuffle(sequence, 32);[m
[31m-	[m
[31m-	// fade in effect, enable random segments.[m
[31m-	// uint32_t fullScreen = 0x00000000;[m
[31m-	uint32_t fullScreen = startScreen;[m
[31m-	[m
[31m-	for (uint8_t i=0; i<step;i++){[m
[31m-		fullScreen |= 1UL <<shuffledSequence[i];// 1UL because if just 1 it's a 16 bit constant. (yep yep Lucie, nonkel Lode lost a couple of hours solving this!)[m
[31m-		[m
[31m-	}[m
[32m+[m[32m    // for (uint8_t i = 0; i < 32; i++) {[m
[32m+[m[32m    //  sequence[i] = i;[m
[32m+[m[32m    // }[m
[32m+[m[41m     [m
[32m+[m[32m    // // shuffle in place[m
[32m+[m[32m    // this->shuffle(sequence, 32);[m
[32m+[m[41m     [m
[32m+[m[32m    // fade in effect, enable random segments.[m
[32m+[m[32m    // uint32_t fullScreen = 0x00000000;[m
[32m+[m[32m    uint32_t fullScreen = startScreen;[m
[32m+[m[41m     [m
[32m+[m[32m    for (uint8_t i=0; i<step;i++){[m
[32m+[m[32m        fullScreen |= 1UL <<shuffledSequence[i];// 1UL because if just 1 it's a 16 bit constant. (yep yep Lucie, nonkel Lode lost a couple of hours solving this!)[m
[32m+[m[41m         [m
[32m+[m[32m    }[m
   return fullScreen;[m
 }[m
[31m-[m
[32m+[m[41m [m
 void Apps::shuffle(uint8_t* listToShuffle, uint8_t length) {[m
[31m-	//shuffle the array:[m
[31m-	//http://www.geeksforgeeks.org/shuffle-a-given-array/[m
[31m-	for (int i = 0; i < length; i++) {[m
[31m-		uint8_t randomIndex = random( i, length);[m
[31m-		[m
[31m-		// swap contents of current index with content further index.[m
[31m-		uint8_t tmp = listToShuffle[i];[m
[31m-		listToShuffle[i] = listToShuffle[randomIndex];[m
[31m-		listToShuffle[randomIndex] = tmp;[m
[31m-	}[m
[31m-}[m
[32m+[m[32m    //shuffle the array:[m
[32m+[m[32m    //http://www.geeksforgeeks.org/shuffle-a-given-array/[m
[32m+[m[32m    for (int i = 0; i < length; i++) {[m
[32m+[m[32m        uint8_t randomIndex = random( i, length);[m
[32m+[m[41m         [m
[32m+[m[32m        // swap contents of current index with content further index.[m
[32m+[m[32m        uint8_t tmp = listToShuffle[i];[m
[32m+[m[32m        listToShuffle[i] = listToShuffle[randomIndex];[m
[32m+[m[32m        listToShuffle[randomIndex] = tmp;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
\ No newline at end of file[m
